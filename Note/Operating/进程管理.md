# 进程、线程、协程的区别

进程、线程和协程是计算机科学中的重要概念，用于描述执行计算任务的不同方式。它们的主要区别如下：

* 进程是操作系统分配资源的基本单位；进程拥有独立的内存空间和系统资源，进程之间的资源是相互隔离的；进程之间通信需要使用IPC机制，如消息队列，管道，信号，共享内存等；进程的创建，销毁和调度开销较大，因为需要分配独立的内存空间和系统资源
* 线程是CPU调度的最小单位，同一个进程下的所有线程共享进程的资源，如内存空间，文件描述符等；线程通过共享内存进行通信；线程的上下文切换要比进程的上下文快；线程的创建，销毁和调度开销较小，因为线程共享进程资源；线程调度由操作系统内核负责，是抢占式调度，每个线程都有自己的栈空间，通常是几百KB到几MB，多线程并发需要考虑线程同步和互斥问题，防止竞争条件和死锁，使用与多核、多处理器环境下的并行计算、可以发挥硬件的性能优势
* 协程是用户程序自身控制，通常是协作式调度；协程的栈空间占用很小，通常为几KB；协程通常使用异步I/O和事件驱动的编程模型，通过回调函数，事件循环等方式处理并发，协程使用于高并发，I/O密集型任务，如网络服务器，爬虫程序等

1. 进程（Process）：进程是操作系统中的一个独立执行单元，具有独立的内存空间和系统资源。一个进程可以包含多个线程。进程之间相互隔离，每个进程有自己的地址空间和文件描述符，不同进程之间的通信需要使用特定的机制，如管道、套接字等。进程之间的切换开销相对较大。

1. 线程（Thread）：线程是进程内的一个执行流，共享同一进程的内存空间和系统资源。多个线程可以同时执行不同的任务，每个线程有自己的栈和局部变量，但共享进程的全局变量和堆内存。线程之间的切换相对于进程要快得多，因为线程共享了大部分上下文信息。

1. 协程（Coroutine）：协程是一种用户级的轻量级线程，由程序控制而非操作系统调度。协程可以在特定的时间点挂起、恢复和切换执行。不同于线程的抢占式调度，协程是协作式调度，需要显式地在代码中插入切换点。协程之间的切换开销非常小。协程通常用于处理高并发、高吞吐量的任务，如网络编程、事件驱动编程等。

总结来说，进程是操作系统分配资源的基本单位，线程是进程内的执行流，而协程是由程序控制的用户级线程。进程之间相互隔离，线程共享同一进程的资源，而协程通过显式的切换点实现协作式调度。不同的场景和需求可能会选择不同的执行模型来实现并发和并行的任务处理。

# 多进程、多线程、多协程场景

多进程：当一个任务非常大或者需要高度的并行性时，可以使用多进程。每个进程都有自己的内存空间和资源，可以独立执行任务。多进程的优点是可以充分利用多核 CPU 的优势，缺点是进程之间的切换开销较大。 多线程：当一个任务需要同时执行多个子任务时，可以使用多线程。每个线程都可以独立执行任务，并且共享内存空间。多线程的优点是线程之间切换的开销较小，缺点是可能会出现线程安全问题，需要使用锁等机制来保护共享资源。 多协程：当一个任务需要进行大量的 I/O 操作或者需要等待某个事件时，可以使用多协程。每个协程都是一个独立的执行线程，可以在需要时挂起和恢复。多协程的优点是可以充分利用 CPU 资源，缺点是协程之间的切换开销较大。 多进程、多线程和多协程的使用场景如下：

 **多进程**： 1. 大规模并行计算 2. 多核 CPU 利用 3. 独立的任务执行 

**多线程**： 1. 同时执行多个子任务 2. 提高程序的并发性 3. 共享内存空间

 **多协程**： 1. I/O 密集型任务 2. 需要等待事件的任务 3. 充分利用 CPU 资源 

总的来说，选择使用多进程、多线程或多协程取决于任务的特征和需求，需要根据具体情况进行权衡和选择。

# 进程线程协程IO占用情况区别

进程、线程和协程在 I/O 占用方面有以下区别： 

**进程**：进程是操作系统中的一个独立运行实体，它拥有自己的内存空间和资源。在执行 I/O 操作时，进程会被阻塞，直到 I/O 操作完成。因此，进程的 I/O 占用比较高，因为它需要等待 I/O 操作完成，并且在等待期间不能执行其他任务。

 **线程**：线程是进程中的一个执行实体，它共享进程的内存空间和资源。在执行 I/O 操作时，线程也会被阻塞，直到 I/O 操作完成。但是，与进程不同的是，线程可以在等待 I/O 操作完成期间被切换到其他线程，从而使得其他线程可以继续执行。因此，线程的 I/O 占用相对较低，因为它可以在等待 I/O 操作完成时切换到其他线程。 

**协程**：协程是线程中的一个执行实体，它也共享进程的内存空间和资源。在执行 I/O 操作时，协程不会被阻塞，而是将其挂起，并在 I/O 操作完成时恢复执行。因此，协程的 I/O 占用非常低，因为它可以在等待 I/O 操作完成时不占用 CPU 资源，而是让其他协程或线程继续执行。 

综上所述，进程的 I/O 占用最高，线程的 I/O 占用相对较低，而协程的 I/O 占用最低。在选择使用哪种方式执行任务时，需要根据任务的特征和需求进行权衡和选择。如果任务需要进行大量的 I/O 操作，那么使用协程可能是更好的选择，因为它可以最大程度地利用 CPU 资源。如果任务需要更快的响应时间，那么使用线程可能是更好的选择，因为它可以在等待 I/O 操作完成时切换到其他线程。



# 进程

在操作系统中，进程（Process）是指正在运行的程序的实例。它是操作系统分配资源、调度和执行任务的基本单位。

## 特点

1. 独立性：每个进程都是独立的，拥有自己的地址空间、内存、文件描述符和其他系统资源。进程之间彼此隔离，互不干扰。
2. 并发执行：操作系统可以同时运行多个进程，通过分配 CPU 时间片给各个进程，实现并发执行。
3. 互相通信：进程之间可以通过进程间通信（IPC）机制进行数据交换和共享资源，例如管道、信号、共享内存等。
4. 生命周期：进程的生命周期包括创建、执行、等待、终止等阶段。进程可以被其他进程创建、终止或等待。
5. 状态：进程可以处于运行态、就绪态、阻塞态等不同的状态，根据操作系统的调度算法进行状态切换。

每个进程都由操作系统分配一个唯一的进程标识符（PID），可以通过 PID 来唯一标识和管理进程。

操作系统通过进程调度器来分配 CPU 时间片给不同的进程，根据调度算法决定哪个进程获得执行。进程可以通过系统调用或中断请求操作系统提供的服务和资源。

进程是操作系统中的核心概念，它使得操作系统能够同时运行多个任务，并提供了资源管理和任务调度的基础。

## 并行和并发

在操作系统中，并行（Parallel）和并发（Concurrent）是两个重要的概念，它们描述了多个任务同时执行的方式。

并行是指两个或多个任务在同一时刻同时执行，每个任务都在自己的处理器核心上独立运行。在并行执行中，多个任务可以在不同的处理器上同时进行，从而实现更高的处理能力和效率。并行处理通常用于并行计算、多核处理器等场景。

并发是指两个或多个任务在一段时间内交替执行，虽然任务可能不是同时发生的，但给人的感觉是同时执行的。在并发执行中，任务之间通过操作系统的调度算法分时共享处理器，并以快速的时间片轮转方式进行切换。并发处理通常用于提高系统的响应性、资源利用率和任务间的交互。

总结一下并行和并发的区别：

- 并行：多个任务在同一时刻同时执行，每个任务独立运行在自己的处理器核心上，实现高效的同时处理能力。
- 并发：多个任务在一段时间内交替执行，通过时间片轮转方式进行切换，实现快速的任务切换和资源共享。

需要根据具体的场景和需求来选择并行还是并发方式，以充分利用系统资源、提高处理能力和响应性。

## 进程的状态

一个进程的活动期间应该具备五种基本状态，即创建状态、运行状态、就绪状态、阻塞状态、结束状态

![image-20230809090744073](D:\typora\Golang_Engineer\typora-user-images\image-20230809090744073.png)

- *NULL -> 创建状态*：一个新进程被创建时的第一个状态；
- *创建状态 -> 就绪状态*：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态，这个过程是很快的；
- *就绪态 -> 运行状态*：处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运行该进程；
- *运行状态 -> 结束状态*：当进程已经运行完成或出错时，会被操作系统作结束状态处理；
- *运行状态 -> 就绪状态*：处于运行状态的进程在运行过程中，由于分配给它的运行时间片用完，操作系统会把该进程变为就绪态，接着从就绪态选中另外一个进程运行；
- *运行状态 -> 阻塞状态*：当进程请求某个事件且必须等待时，例如请求 I/O 事件；
- *阻塞状态 -> 就绪状态*：当进程要等待的事件完成时，它从阻塞状态变到就绪状态；

## 进程的控制结构

在操作系统中，是用进程控制块（PCB)数据结构来描述进程的。**PCB是进程存在的唯一标识**

### PCB包含什么信息

- 进程描述信息

- 进程控制和管理信息
- 资源分配清单
- CPU相关信息

每个PCB通常通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列。

## 进程上下文切换

在操作系统中，进程上下文切换是指从一个正在运行的进程切换到另一个就绪态的进程，使得另一个进程可以继续执行。上下文切换发生的时候，操作系统会保存当前进程的状态（上下文），包括寄存器的值、程序计数器、堆栈指针和其他相关信息，并加载下一个进程的状态，以便让其继续执行。

进程上下文切换的过程包括以下步骤：

1. 保存当前进程的上下文：操作系统会保存当前进程的寄存器状态、程序计数器和其他相关寄存器的值，以及进程的堆栈指针等信息。

2. 切换到目标进程：操作系统根据调度算法选择下一个要执行的进程，并加载该进程的上下文。这包括恢复目标进程的寄存器状态、程序计数器和堆栈指针等。

3. 更新内核数据结构：操作系统会更新内核的进程控制块（PCB）等数据结构，记录进程切换的相关信息。

4. 执行目标进程：操作系统将控制权转移到目标进程，使其开始执行。

进程上下文切换是操作系统实现进程调度和并发执行的重要机制。它允许多个进程在一个处理器上交替执行，实现并发性和共享资源。然而，上下文切换也会带来一定的开销，包括保存和恢复进程的上下文、更新数据结构等，因此需要在性能和响应性之间进行权衡。优化上下文切换的方式包括减少切换次数、减少上下文保存的数据量等。

操作系统中的进程上下文切换是一个复杂的过程，涉及保存当前进程的状态和加载新进程的状态。以下是进程上下文切换的一般步骤：

1. **中断/陷入处理**：
   当一个进程正在执行时，可能会因为多种原因（如时钟中断、I/O完成、系统调用等）被操作系统中断。中断发生后，CPU的控制权会转移到操作系统。
2. **保存当前进程的上下文**：
   - **寄存器状态**：CPU的寄存器（如程序计数器、栈指针、通用寄存器等）中存储了当前进程的执行状态。这些寄存器的值需要被保存到该进程的进程控制块（PCB）或某个特定的内存区域。
   - **内存状态**：如果进程使用了某些内存区域（如堆、栈），则这些区域的状态也可能需要保存。但通常，进程的内存状态是持久的，不需要在每次上下文切换时都保存。
   - **其他状态**：如文件描述符、信号状态、浮点状态等也可能需要保存。
3. **选择新进程**：
   操作系统根据调度算法从就绪队列中选择一个新的进程来执行。
4. **加载新进程的上下文**：
   - 从新进程的PCB或特定的内存区域加载寄存器的状态。
   - 如果需要，设置新进程的内存管理信息，如页表。
   - 加载其他与新进程相关的状态。
5. **更新相关数据结构**：
   如更新就绪队列、进程状态等。
6. **开始执行新进程**：
   设置程序计数器为新进程的起始地址，然后CPU开始执行新进程。

需要注意的是，上下文切换的开销是相对较大的，因为它涉及保存和加载大量的CPU状态。为了减少上下文切换的开销，现代操作系统和硬件都提供了各种优化技术，如使用快速的硬件上下文切换机制、使用TLB（Translation Lookaside Buffer）来缓存页表项等。

### 进程上下文切换发生的场景

进程上下文切换在以下几种情况下会发生：

1. 抢占式调度：当操作系统采用抢占式调度算法时，可能会在一个进程被抢占（被更高优先级的进程取代）时发生上下文切换。这可以是由于时间片用完、高优先级进程就绪或中断事件发生等原因。

2. 阻塞和唤醒：当进程请求某个事件（如等待 I/O 完成）而无法继续执行时，操作系统会将该进程阻塞，并将 CPU 分配给另一个就绪态的进程。当等待的事件完成后，操作系统会将进程唤醒，并进行上下文切换，使其继续执行。

3. 多任务环境切换：当操作系统运行多个任务时，通过时间片轮转或优先级调度等方式，会在进程之间进行切换，以实现并发执行。这种情况下，操作系统会周期性地进行上下文切换，以平衡各个任务的执行和资源利用。

4. 中断处理：当发生硬件中断或软件中断（如系统调用）时，操作系统会暂停当前进程的执行，保存其上下文，并切换到中断处理程序。中断处理程序执行完后，操作系统会恢复先前被中断的进程的上下文，使其继续执行。

需要注意的是，进程上下文切换是一种开销较高的操作，因为它涉及到保存和恢复大量的寄存器状态和内核数据结构。因此，在设计和优化系统时，需要合理选择调度算法、减少上下文切换次数，以提高系统的性能和响应性。

## 进程的通信方式

在操作系统中，进程之间可以通过多种方式进行通信，以实现数据交换、共享资源和协作完成任务。常见的进程通信方式包括：

1. 管道（Pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。它是基于操作系统内核提供的缓冲区实现的，通过将一个进程的输出连接到另一个进程的输入来实现进程间通信。当一个进程向管道中写入数据时，数据会被存储在管道的缓冲区中，等待另一个进程从管道中读取数据。管道的缓冲区是有限的，如果写入进程在缓冲区已满时仍然写入，那么它会被阻塞，直到另一个进程从管道中读取数据。

2. 命名管道（Named Pipe）：有名管道（也称为命名管道或FIFO）是管道的扩展，它允许无亲缘关系进程间的通信。有名管道提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中。这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信。

3. 信号（Signal）：信号是一种异步通信机制，用于通知进程发生了某个事件。进程可以通过发送信号给其他进程，来请求某种操作或通知其发生的事件。

4. 共享内存（Shared Memory）：共享内存允许多个进程访问同一块内存空间，是最快的一种进程间通信方式。但是，由于多个进程可以同时访问，所以需要某种同步机制（如信号量）以避免对共享内存的冲突访问。共享内存是通过映射一段能被其他进程所访问的内存来实现的，这段共享内存由一个进程创建，但多个进程都可以访问。它往往与其他通信机制（如信号量）配合使用，来实现进程间的同步和通信。

5. 消息队列（Message Queue）：消息队列是消息的链接列表，存储在内核中并由消息队列标识符标识。它是一个消息的集合，每个消息都有一个特定的类型，进程可以按类型读写消息队列。消息队列允许一个或多个进程向它写入或从中读取消息，不需要读写进程同步，因为系统提供了消息队列的同步机制。消息队列的实现包括POSIX消息队列和System V消息队列，前者提供了更强大和灵活的功能。

6. 信号量（Semaphore）：信号量是一个计数器，用于控制多个进程对共享资源的访问。它通常作为一种同步机制，用于防止多个进程同时访问同一资源时产生冲突。但是，信号量本身也可以用于进程间通信，比如一个进程可以通过改变信号量的值来向另一个进程发送消息。不过，信号量更常用于同步而非通信。

7. 套接字（Socket）：套接字也是一种进程间通信方式，与其他通信机制相比，它的最大优点是不受本地限制，即可以通过网络在不同机器上的进程间进行通信。套接字是网络通信的基本操作单元，提供了不同主机间进程双向通信的端点。套接字的使用需要遵循一定的协议，如TCP/IP、UDP等。

这些进程通信方式各有特点，适用于不同的场景和需求。在选择进程通信方式时，需要考虑进程间的关系、数据量、性能要求和安全性等因素。

### 管道是怎么利用存储的

管道是一种用于在操作系统进程之间通信的方式。它利用了内存的缓冲区来存储数据，从而实现进程之间的数据交换。

具体来说，管道是一种半双工的通信方式，它允许两个进程之间相互发送数据。每个进程都有一个固定大小的缓冲区，用于存储接收到的数据。当一个进程需要向另一个进程发送数据时，它会将数据写入到自己的缓冲区中，然后通知另一个进程读取数据。另一个进程接收到通知后，会从对方的缓冲区中读取数据，并进行处理。

管道的优点是它允许两个进程之间进行高效的数据交换，并且不需要使用复杂的 IPC（Inter-Process Communication）机制。但是，管道也有一些缺点，例如它只能用于发送和接收文本数据，不能发送二进制数据，而且它的缓冲区大小是固定的，不能动态调整。

总的来说，管道是一种简单、高效的进程间通信方式，适用于一些特定的场景。但是，在需要更复杂的通信机制的情况下，可能需要使用其他的 IPC 技术，如消息队列、共享内存等。

### 管道读取效率高吗？

管道读取的效率相对较高，尤其在某些场景下。以下是一些有关管道读取效率的考虑因素：

1. 延迟和吞吐量：管道是一种用于进程间通信的机制，它可以在不同进程之间传递数据。相比于其他进程间通信方式（如共享内存），管道通常具有较低的延迟和较高的吞吐量。这是因为管道是基于内核缓冲区实现的，可以使用较小的数据块进行快速传输。
2. 缓冲区大小：管道的性能可能受到缓冲区大小的影响。较大的缓冲区可以减少管道的上下文切换次数，从而提高读取效率。然而，过大的缓冲区也可能导致数据积压和延迟增加。因此，选择适当的缓冲区大小是优化管道读取效率的一个关键因素。
3. 阻塞与非阻塞：管道的读取可以是阻塞或非阻塞的。阻塞读取意味着读取操作将一直等待，直到有数据可用。非阻塞读取则会立即返回，并根据数据的可用性返回相应的结果。非阻塞读取可以提高管道的响应性和并发性能，尤其在需要同时处理多个管道时。

需要注意的是，管道的效率也受到其他因素的影响，如数据量大小、读取和写入进程之间的速度差异等。此外，具体的应用场景和需求也会影响管道读取的效率评估。因此，在实际应用中，对于特定的数据传输需求，最好进行基准测试和性能分析，以确定管道是否适合并满足预期的读取效率。

# 线程

## 什么是线程

**线程是进程当中的一条执行流程，是CPU调度的最小单位。**

## 多线程是并发IO吗？

是的，多线程可以实现并发 I/O。多线程是指在同一个进程中同时运行多个线程，每个线程都可以独立地执行代码。在多线程环境下，多个线程可以同时访问同一个文件、网络套接字等 I/O 资源，从而实现并发 I/O。

并发 I/O 可以提高系统的吞吐量和响应速度，因为它允许多个线程同时进行 I/O 操作，而不是让单个线程独占 I/O 资源。这样，当一个线程在进行 I/O 操作时，其他线程可以继续执行其他任务，从而减少了线程的阻塞时间，提高了系统的效率。

但是，并发 I/O 也存在一些挑战和风险。例如，多个线程同时访问同一个 I/O 资源可能会导致竞争条件和同步问题，需要使用锁、信号量等同步机制来解决。此外，并发 I/O 也可能会导致数据的不一致性和错误，需要在设计和实现时加以注意。

## 线程冲突

线程冲突是指在多线程编程中，多个线程同时访问共享资源时可能引发的问题。这些问题包括数据竞争、死锁和活锁等。

1. 数据竞争（Data Race）：数据竞争是最常见的线程冲突问题。当多个线程同时访问和修改共享的数据时，如果没有适当的同步机制保证互斥访问，就可能导致数据的不一致和错误。例如，多个线程同时对同一个变量进行写操作，会导致不确定的结果。
2. 死锁（Deadlock）：死锁是指多个线程因为相互等待对方释放资源而无法继续执行的情况。当多个线程持有某些资源，并且需要等待其他线程释放它们所持有的资源时，如果形成了一个闭环等待的状态，就会导致死锁。
3. 活锁（Livelock）：活锁是指多个线程在并发执行时，由于彼此响应对方的动作而无法继续执行的情况。线程可能会反复尝试执行某个操作，但由于其他线程的干扰，无法取得进展。

解决线程冲突的常用方法包括：

1. 互斥锁（Mutex）：使用互斥锁可以实现对共享资源的互斥访问，一次只允许一个线程访问共享资源，其他线程需要等待锁释放后才能继续执行。
2. 条件变量（Condition Variable）：条件变量用于线程间的等待和通知机制，可以实现线程的等待和唤醒操作，避免了忙等待的情况。
3. 读写锁（Read-Write Lock）：读写锁允许多个线程同时读取共享资源，但只允许一个线程进行写操作。这样可以提高读操作的并发性能。
4. 原子操作（Atomic Operation）：原子操作是不可分割的操作，可以确保对共享资源的操作是原子的，避免了数据竞争问题。
5. 同步工具（Synchronization Primitives）：除了上述基本的同步机制，还有一些更高级的同步工具，如信号量（Semaphore）、屏障（Barrier）等，可以根据具体需求选择合适的工具。

正确地设计和实现线程同步机制是解决线程冲突的关键，避免数据竞争和死锁等问题的发生。同时，对于复杂的并发场景，还需要进行仔细的测试和调试，以确保线程安全性和正确性。

线程冲突（Thread Conflict）通常指的是多线程编程中可能出现的问题，其中两个或多个线程同时访问共享资源（如内存位置、文件、数据库连接等）并试图同时修改它，导致数据的不一致或其他未定义的行为。线程冲突是多线程并发执行时的常见问题，也称为竞态条件（Race Condition）。

竞态条件的发生是因为线程的执行顺序和时间是由操作系统的调度算法控制的，而这个调度对于程序员来说是不可预测的。因此，当多个线程访问共享资源时，如果没有适当的同步机制，就可能出现线程冲突。

以下是一些可能导致线程冲突的情况和相应的解决方法：

1. 共享变量的访问：

   - 当多个线程同时读写共享变量时，可能会导致数据不一致。
   - 解决方法：使用互斥锁（Mutexes）、读写锁（Read-Write Locks）、原子操作（Atomic Operations）等来确保对共享变量的访问是互斥的。

2. 文件或数据库访问：

   - 当多个线程同时写入同一个文件或数据库记录时，可能会导致数据损坏或丢失。
   - 解决方法：使用文件锁（File Locks）、数据库事务（Database Transactions）等机制来确保对资源的独占访问。

3. 线程间的通信：

   - 当使用条件变量（Condition Variables）、信号量（Semaphores）等进行线程间通信时，如果不正确使用这些同步原语，也可能导致死锁（Deadlock）或活锁（Livelock）等问题。
   - 解决方法：确保正确使用同步原语，遵循特定的协议和顺序来避免死锁等问题。

4. 资源分配：

   - 当多个线程竞争有限的资源（如连接池中的连接）时，如果没有适当的资源管理策略，可能会导致资源耗尽或分配不均。
   - 解决方法：使用资源池（Resource Pools）、工作队列（Work Queues）等机制来管理资源的分配和释放。

5. 指令重排

   ：

   - 编译器和处理器可能会对指令进行重排序以优化性能，这可能导致多线程程序中的线程冲突。
   - 解决方法：使用内存屏障（Memory Barriers）或原子操作来确保指令的执行顺序符合预期。

为了避免线程冲突，程序员需要仔细设计多线程程序，确保对共享资源的访问是安全的。这通常涉及到使用适当的同步机制、理解并发编程的基本原则以及进行充分的测试来验证程序的正确性。

## 线程的优缺点

线程的优点：

- 一个进程中可以同时存在多个线程；
- 各个线程之间可以并发执行；
- 各个线程之间可以共享地址空间和文件等资源；

线程的缺点：

- 当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C/C++ 语言）

## 进程线程的区别

进程和线程是操作系统中的两个重要概念，它们有以下区别：

1. 定义：进程是正在执行的程序的实例，是资源分配和调度的基本单位。线程是进程内部的执行单元，是进程的一个独立执行流程。

2. 资源和隔离：每个进程都有独立的地址空间、文件描述符、堆栈等资源，进程之间相互隔离。而线程是共享进程的资源，包括内存空间、文件描述符等。线程之间可以直接访问和共享数据，需要注意同步和互斥。

3. 创建和切换开销：创建进程需要分配独立的资源和建立相应的数据结构，开销较大。而创建线程的开销较小，因为线程共享进程的资源，只需要分配线程控制块。线程的切换开销也较小，因为它们共享进程的地址空间和其他资源。

4. 并发性：进程是操作系统分配资源和调度任务的基本单位，可以并发执行多个进程。而线程是进程内部的执行单元，多个线程可以在同一进程中并发执行。

5. 通信和同步：进程之间通信需要使用进程间通信（IPC）机制，如管道、消息队列、共享内存等。线程之间可以通过共享内存、信号量、互斥锁等机制进行通信和同步。

6. 失败影响：一个进程的失败通常不会影响其他进程。而一个线程的失败会导致整个进程的失败。

需要根据具体的应用需求和系统特点来选择使用进程还是线程。进程适合于独立的任务和资源隔离，线程适合于并发执行和共享的任务。多线程编程可以提高系统的性能和响应性，但同时也需要注意线程间的同步和互斥，避免竞态条件和数据不一致的问题。

## 线程的上下文切换

- 当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；
- **当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**；

在操作系统中，线程上下文切换是指从一个正在执行的线程切换到另一个就绪态的线程，以便让另一个线程继续执行。线程上下文切换涉及保存当前线程的上下文，并加载下一个线程的上下文。

线程上下文切换的过程包括以下步骤：

1. 保存当前线程的上下文：操作系统会保存当前线程的寄存器状态、程序计数器和其他寄存器的值，以及线程的堆栈指针等信息。

2. 切换到目标线程：操作系统根据调度算法选择下一个要执行的线程，并加载该线程的上下文。这包括恢复目标线程的寄存器状态、程序计数器和堆栈指针等。

3. 更新内核数据结构：操作系统会更新内核的线程控制块（TCB）等数据结构，记录线程切换的相关信息。

4. 执行目标线程：操作系统将控制权转移到目标线程，使其开始执行。

线程上下文切换是操作系统实现多线程并发执行的重要机制。它允许多个线程在同一进程中交替执行，实现并发性和共享资源。然而，上下文切换也会带来一定的开销，包括保存和恢复线程的上下文、更新数据结构等，因此需要在性能和响应性之间进行权衡。优化上下文切换的方式包括减少切换次数、减少上下文保存的数据量等。

需要注意的是，线程上下文切换与进程上下文切换相比，开销较小，因为线程共享进程的资源和地址空间。因此，多线程编程可以更高效地利用系统资源，提高程序的性能和响应性。

## 线程的实现

- 用户线程：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理

- 内核线程：在内核中实现的线程，是由内核管理的线程
- 轻量级线程：在内核中来支持用户线程

### 用户线程和内核线程的对应关系

- 一对一
- 多对一
- 多对多

## 用户线程如何理解、优缺点

用户线程是基于用户态的线程管理库来实现的，那么**线程控制块（\*Thread Control Block, TCB\*）** 也是在库里面来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB。所以，**用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。**

用户线程的**优点**：

- 每个进程都需要有它私有的线程控制块（TCB）列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB 由用户级线程库函数来维护，可用于不支持线程技术的操作系统；
- 用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快；

用户线程的**缺点**：

- 由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了。
- 当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的。
- 由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会比较慢；

## 内核线程如何理解、优缺点

**内核线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。**

内核线程的**优点**：

- 在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；
- 分配给线程，多线程的进程获得更多的 CPU 运行时间；

内核线程的**缺点**：

- 在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB；
- 线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大；

## 轻量级线程如何理解

**轻量级进程（\*Light-weight process，LWP\*）是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持，而且 LWP 是由内核管理并像普通进程一样被调度**。在大多数系统中，**LWP与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息**。

 LWP 与用户线程的对应关系就有三种：

- `1 : 1`，即一个 LWP 对应 一个用户线程；
- `N : 1`，即一个 LWP 对应多个用户线程；
- `M : N`，即多个 LWP 对应多个用户线程；

# 调度

## 调度时机

以下状态的变化都会触发操作系统的调度：

- *从就绪态 -> 运行态*：当进程被创建时，会进入到就绪队列，操作系统会从就绪队列选择一个进程运行；
- *从运行态 -> 阻塞态*：当进程发生 I/O 事件而阻塞时，操作系统必须选择另外一个进程运行；
- *从运行态 -> 结束态*：当进程退出结束后，操作系统得从就绪队列选择另外一个进程运行；

## 调度算法

- **非抢占式调度算法**挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。
- **抢占式调度算法**挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生**时钟中断**，以便把 CPU 控制返回给调度程序进行调度，也就是常说的**时间片机制**。

## 调度原则

- **CPU 利用率**：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；
- **系统吞吐量**：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；
- **周转时间**：周转时间是进程运行+阻塞时间+等待时间的总和，一个进程的周转时间越小越好；
- **等待时间**：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；
- **响应时间**：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。

## 调度算法

调度算法是操作系统中用于决定哪个进程或线程获得 CPU 时间片并执行的策略。调度算法的选择对系统的性能、响应时间和资源利用率等方面有重要影响。

常见的调度算法包括：

1. 先来先服务（FCFS，First-Come, First-Served）：按照进程到达的顺序进行调度，先到达的进程先执行。这是一种非抢占式调度算法，适用于长作业时间的进程。然而，FCFS 可能导致短进程等待时间过长，产生“饥饿”现象。

2. 最短作业优先（SJF，Shortest Job First）：选择估计执行时间最短的进程优先执行。SJF 是一种非抢占式调度算法，理论上可以实现最优的平均等待时间。但是，对于无法准确估计执行时间的情况，可能导致长作业的等待时间过长。

3. 优先级调度：为每个进程分配一个优先级，并按照优先级高低进行调度。优先级可以是静态的，由进程属性决定，也可以是动态的，根据进程的行为和状态进行调整。优先级调度可以是抢占式或非抢占式的。

4. 时间片轮转（RR，Round Robin）：按照时间片的大小，为每个进程分配固定的执行时间，轮流执行。当时间片用完时，进程被放回就绪队列，等待下一次调度。时间片轮转是一种公平的调度算法，可以避免长作业等待时间过长，但可能导致上下文切换的开销增加。

5. 多级反馈队列（MFQ，Multi-Level Feedback Queue）：将进程划分为多个队列，每个队列有不同的优先级和时间片大小。进程先进入高优先级队列，如果用完时间片还未执行完，则进入下一级低优先级队列。这种调度算法可以在保证短作业优先的同时，也允许长作业得到一定的执行时间。

6. 高响应比优先调度算法：高响应比优先 （\*Highest Response Ratio Next, HRRN\*）调度算法主要是权衡了短作业和长作业。每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行，响应比优先级的计算公式：

   ![image-20240109205702191](D:\typora\Golang_Engineer\typora-user-images\image-20240109205702191.png)

选择合适的调度算法需要根据系统的需求和性能要求。不同的调度算法可能适用于不同的场景，需要权衡任务的响应时间、资源利用率和公平性等因素。另外，一些高级调度算法，如实时调度算法和动态优先级调度算法，还可以根据任务的特殊需求和时间约束进行调度。

# 多线程冲突怎么办

当多个线程同时访问共享数据或共享资源时，可能会出现冲突和竞态条件。这种情况下，需要采取适当的措施来处理多线程冲突，以确保数据的一致性和避免意外的错误。

以下是一些常用的处理多线程冲突的方法：

1. 互斥锁：使用互斥锁（Mutex）来保护共享资源。在访问共享资源之前，线程会尝试获取互斥锁。如果互斥锁被其他线程持有，则线程会被阻塞，直到锁被释放。一次只能有一个线程获得互斥锁，从而确保对共享资源的独占访问。

2. 读写锁：对于共享资源的读操作，可以使用读写锁（ReadWrite Lock）。读写锁允许多个线程同时读取共享资源，但只允许一个线程进行写操作。这样可以提高并发性，同时确保对共享资源的写操作是互斥的。

3. 原子操作：对于简单的操作，可以使用原子操作来确保操作的原子性。原子操作是不可中断的，可以在一个步骤中完成，不会被其他线程打断。

4. 条件变量：使用条件变量（Condition Variable）来实现线程之间的等待和通知机制。当线程需要等待某个条件满足时，可以进入等待状态，并释放锁。当条件满足时，其他线程可以通过条件变量来通知等待的线程恢复执行。

5. 同步工具：使用其他同步工具，如信号量（Semaphore）、屏障（Barrier）等，来控制多线程间的同步和互斥。

6. 避免竞态条件：在设计和编写代码时，尽量避免竞态条件的产生。可以通过合理的数据结构设计、避免共享数据、使用不可变对象等方式来减少竞态条件的发生。

以上方法都是为了避免多线程冲突和提供线程间的协调机制。选择适当的方法需要根据实际情况和需求来确定，以确保程序的正确性和性能。同时，需要注意避免死锁、活锁和饥饿等并发编程中的常见问题。

系统的稳定性，线程的异常处理是一个重要的设计考虑因素。

# 线程崩溃，进程一定崩溃吗？

一般来说如果线程是因为非法访问内存引起的崩溃，那么进程肯定会崩溃，为什么系统要让进程崩溃呢，这主要是因为在进程中，**各个线程的地址空间是共享的**，既然是共享，那么某个线程对地址的非法访问就会导致内存的不确定性，进而可能会影响到其他线程，这种操作是危险的，操作系统会认为这很可能导致一系列严重的后果，于是干脆让整个进程崩溃

1. 针对只读内存写入数据
2. 访问了进程没有权限访问的地址空间（比如内核空间）
3. 访问了不存在的内存

在操作系统中，线程和进程是不同的概念。一个进程可以包含多个线程，线程是进程内的执行单元。当一个线程崩溃并引发异常时，并不一定会导致整个进程崩溃。

在典型情况下，当一个线程崩溃时，操作系统会捕获异常并尝试处理它。操作系统可以选择终止崩溃的线程，然后允许其他线程继续执行。这种情况下，崩溃的线程会被“终止”，而不是整个进程被终止。

然而，有一些情况下线程的崩溃可能会影响整个进程的稳定性：

1. **共享资源问题：** 如果线程崩溃导致共享资源状态不一致或资源泄漏，这可能会影响其他线程的正常执行。

2. **线程间通信问题：** 如果线程之间通过消息传递、信号量、锁等机制进行通信，崩溃的线程可能会破坏这些通信机制，影响其他线程之间的协作。

3. **内存问题：** 一些崩溃可能会导致内存损坏或泄漏，这可能会影响整个进程的稳定性。

4. **异常处理问题：** 如果崩溃的线程的异常处理不当，可能会导致进程崩溃。例如，未捕获的异常可能会传播到进程级别。

总的来说，虽然线程的崩溃不一定会导致整个进程的崩溃，但线程崩溃可能会对进程的正常运行产生负面影响，特别是当线程之间有强烈的依赖关系、共享资源或通信机制时。为了确保