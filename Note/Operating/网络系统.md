# 什么是零拷贝

磁盘是计算机系统最慢的的硬件之一，所以有不少优化磁盘的方法，比如零拷贝、直接IO、异步IO等等，这些优化的目的是为了提高系统的吞吐量，另外操作系统内核中的磁盘高度缓存区，可以有效的减少磁盘的访问次数。

## 为什么要有DMA技术

没有DMA技术之前，IO过程是这样的：

- CPU 发出对应的指令给磁盘控制器，然后返回；
- 磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个**中断**；
- CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。

在整个数据传输过程中，都需要CPU亲自参与搬运数据的过程，期间CPU不能做其他事情，简单搬运几个字符串数据没问题，如果用千兆网卡或者硬盘传输大量数据的时候，都用CPU来搬运的话，肯定忙不过来。于是就有了DMA技术，直接内存访问（Direct Memory Access）技术。

什么是 DMA 技术？简单理解就是，**在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务**。

![image-20230812092630911](D:\typora\Golang_Engineer\typora-user-images\image-20230812092630911.png)



具体过程：

- 用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；
- 操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；
- DMA 进一步将 I/O 请求发送给磁盘；
- 磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；
- **DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务**；
- 当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；
- CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；

可以看到， **CPU 不再参与「将数据从磁盘控制器缓冲区搬运到内核空间」的工作，这部分工作全程由 DMA 完成**。但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。

## 传统的文件传输方式

传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。代码通常如下，一般会需要两个系统调用：

```c
read(file, tmp_buf, len);
write(socket, tmp_buf, len);
```

代码很简单，虽然就两行代码，但是这里面发生了不少的事情。

![image-20230812092954983](D:\typora\Golang_Engineer\typora-user-images\image-20230812092954983.png)

首先，期间共**发生了 4 次用户态与内核态的上下文切换**，因为发生了两次系统调用，一次是 `read()` ，一次是 `write()`，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。其次，还**发生了 4 次数据拷贝**，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：

- *第一次拷贝*，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。
- *第二次拷贝*，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。
- *第三次拷贝*，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。
- *第四次拷贝*，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。

所以，**要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数**。

## 优化文件传输的性能

**要想减少上下文切换的次数，就要减少系统调用的次数**。传统的文件传输方式会历经 4 次数据拷贝，而且这里面，「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」，这个过程是没有必要的。因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此**用户的缓冲区是没有必要存在的**。

## 如何实现零拷贝技术

零拷贝技术实现的方式通常有 2 种：

- mmap + write：mmap代替read ， 三次拷贝，四次上下文切换
- sendfile：sendfile代替read和write，三次拷贝，两次上下文切换；如果网卡支持 SG-DMA 技术，则就会发生两次拷贝，两次上下文切换

### mmap+write

`read()` 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 `mmap()` 替换 `read()` 系统调用函数。

```c
buf = mmap(file, len);
write(sockfd, buf, len);
```

`mmap()` 系统调用函数会直接把内核缓冲区里的数据「**映射**」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。

![image-20230812144519844](D:\typora\Golang_Engineer\typora-user-images\image-20230812144519844.png)

具体过程如下：

- 应用进程调用了 `mmap()` 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；
- 应用进程再调用 `write()`，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；
- 最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。

我们可以得知，通过使用 `mmap()` 来代替 `read()`， 可以减少一次数据拷贝的过程。但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。

### sendfile

在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 `sendfile()`，函数形式如下：

```c
#include <sys/socket.h>
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
```

它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。首先，它可以替代前面的 `read()` 和 `write()` 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：

![image-20230812144930501](D:\typora\Golang_Engineer\typora-user-images\image-20230812144930501.png)

但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（*The Scatter-Gather Direct Memory Access*）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。

你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：

```bash
$ ethtool -k eth0 | grep scatter-gather
scatter-gather: on
```

于是，从 Linux 内核 `2.4` 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， `sendfile()` 系统调用的过程发生了点变化，具体过程如下：

- 第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；
- 第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；

所以，这个过程之中，只进行了 2 次数据拷贝，如下图：

![image-20230812145032868](D:\typora\Golang_Engineer\typora-user-images\image-20230812145032868.png)

这就是所谓的**零拷贝（\*Zero-copy\*）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。**。

零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，**只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。**所以，总体来看，**零拷贝技术可以把文件传输的性能提高至少一倍以上**

## 使用零拷贝技术的项目

### kafka

Kafka 这个开源项目，就利用了「零拷贝」技术，从而大幅提升了 I/O 的吞吐率，这也是 Kafka 在处理海量数据为什么这么快的原因之一。如果你追溯 Kafka 文件传输的代码，你会发现，最终它调用了 Java NIO 库里的 `transferTo` 方法：

```java
@Overridepublic 
long transferFrom(FileChannel fileChannel, long position, long count) throws IOException { 
    return fileChannel.transferTo(position, count, socketChannel);
}
```

如果 Linux 系统支持 `sendfile()` 系统调用，那么 `transferTo()` 实际上最后就会使用到 `sendfile()` 系统调用函数。

### Nginx

另外，Nginx 也支持零拷贝技术，一般默认是开启零拷贝技术，这样有利于提高文件传输的效率，是否开启零拷贝技术的配置如下：

```text
http {
...
    sendfile on
...
}
```

sendfile 配置的具体意思:

- 设置为 on 表示，使用零拷贝技术来传输文件：sendfile ，这样只需要 2 次上下文切换，和 2 次数据拷贝。
- 设置为 off 表示，使用传统的文件传输技术：read + write，这时就需要 4 次上下文切换，和 4 次数据拷贝。

当然，要使用 sendfile，Linux 内核版本必须要 2.1 以上的版本。

## 磁盘高速缓存(PageCache)

文件传输过程，其中第一步都是先需要先把磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是**磁盘高速缓存（\*PageCache\*）**。

读写磁盘相比读写内存的速度慢太多了，所以我们应该想办法把「读写磁盘」替换成「读写内存」。于是，我们会通过 DMA 把磁盘里的数据搬运到内存里，这样就可以用读内存替换读磁盘。但是，内存空间远比磁盘要小，内存注定只能拷贝磁盘里的一小部分数据。

那问题来了，选择哪些磁盘数据拷贝到内存呢？

我们都知道程序运行的时候，具有「局部性」，所以通常，刚被访问的数据在短时间内再次被访问的概率很高，于是我们可以用 **PageCache 来缓存最近被访问的数据**，当空间不足时淘汰最久未被访问的缓存。

所以，读磁盘数据的时候，优先在 PageCache 找，如果数据存在则可以直接返回；如果没有，则从磁盘中读取，然后缓存 PageCache 中。还有一点，读取磁盘数据的时候，需要找到数据所在的位置，但是对于机械磁盘来说，就是通过磁头旋转到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是非常耗时的，为了降低它的影响，**PageCache 使用了「预读功能」**。

### PageCache的优点

- 缓存最近被访问的数据；
- 预读功能；

这两个做法，将大大提高读写磁盘的性能。**但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能**另外，由于文件太大，可能某些部分的文件数据被再次访问的概率比较低，这样就会带来 2 个问题：

- PageCache 由于长时间被大文件占据，其他「热点」的小文件可能就无法充分使用到 PageCache，于是这样磁盘读写的性能就会下降了；
- PageCache 中的大文件数据，由于没有享受到缓存带来的好处，但却耗费 DMA 多拷贝到 PageCache 一次；

所以，针对大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，这样在高并发的环境下，会带来严重的性能问题。

## 大文件传输实现方法

当调用 read 方法读取文件时，进程实际上会阻塞在 read 方法调用，因为要等待磁盘数据的返回，如下图：

![image-20230812145803784](D:\typora\Golang_Engineer\typora-user-images\image-20230812145803784.png)

具体过程：

- 当调用 read 方法时，会阻塞着，此时内核会向磁盘发起 I/O 请求，磁盘收到请求后，便会寻址，当磁盘数据准备好后，就会向内核发起 I/O 中断，告知内核磁盘数据已经准备好；
- 内核收到 I/O 中断后，就将数据从磁盘控制器缓冲区拷贝到 PageCache 里；
- 最后，内核再把 PageCache 中的数据拷贝到用户缓冲区，于是 read 调用就正常返回了。

对于阻塞的问题，可以用异步 I/O 来解决，它工作方式如下图：

![image-20230812145923704](D:\typora\Golang_Engineer\typora-user-images\image-20230812145923704.png)

它把读操作分为两部分：

- 前半部分，内核向磁盘发起读请求，但是可以**不等待数据就位就可以返回**，于是进程此时可以处理其他任务；
- 后半部分，当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的**通知**，再去处理数据；

而且，我们可以发现，异步 I/O 并没有涉及到 PageCache，所以使用异步 I/O 就意味着要绕开 PageCache。

绕开 PageCache 的 I/O 叫直接 I/O，使用 PageCache 的 I/O 则叫缓存 I/O。通常，对于磁盘，异步 I/O 只支持直接 I/O。

前面也提到，大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。于是，**在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术**。

直接 I/O 应用场景常见的两种：

- 应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I/O，默认是不开启；
- 传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I/O。

另外，由于直接 I/O 绕过了 PageCache，就无法享受内核的这两点的优化：

- 内核的 I/O 调度算法会缓存尽可能多的 I/O 请求在 PageCache 中，最后「**合并**」成一个更大的 I/O 请求再发给磁盘，这样做是为了减少磁盘的寻址操作；
- 内核也会「**预读**」后续的 I/O 请求放在 PageCache 中，一样是为了减少对磁盘的操作；

于是，传输大文件的时候，使用「异步 I/O + 直接 I/O」了，就可以无阻塞地读取文件了。

所以，传输文件的时候，我们要根据文件的大小来使用不同的方式：

- 传输大文件的时候，使用「异步 I/O + 直接 I/O」；
- 传输小文件的时候，则使用「零拷贝技术」；

在 nginx 中，我们可以用如下配置，来根据文件的大小来使用不同的方式：

```text
location /video/ { 
    sendfile on; 
    aio on; 
    directio 1024m; 
}
```

当文件大小大于 `directio` 值后，使用「异步 I/O + 直接 I/O」，否则使用「零拷贝技术」。

## 面试题

### 什么是零拷贝技术

- 零拷贝技术是一种优化技术，用于减少数据在内核空间和用户空间之间的拷贝次数，从而提高数据传输的效率。通过避免不必要的数据拷贝，直接将数据从源缓冲区传输到目标缓冲区，减少CPU的负担，提升系统性能。

### 零拷贝技术的优点

- 提高传输效率：避免了不必要的数据拷贝，减少了CPU的负担，提高了数据传输的效率。
- 减少内存消耗：不需要额外的缓冲区来存储中间数据，减少了内存的消耗。
- 提升系统性能：减少了CPU的工作量，提高了系统的响应性能和吞吐量。

### 零拷贝技术的实现方式

- DMA（Direct Memory Access）：通过DMA技术，设备可以直接将数据传输到内存，避免了CPU的干预。
- sendfile()：通过sendfile()系统调用，将文件内容直接传输到网络协议栈的缓冲区，避免了中间缓冲区的拷贝。
- mmap()：通过mmap()系统调用，将磁盘文件映射到进程的虚拟地址空间，实现直接在用户空间访问文件内容。
- splice()：通过splice()系统调用，在两个文件描述符之间直接进行数据传输，避免了用户空间的中间缓冲区。

### 零拷贝技术可能存在的问题

- 对操作系统和硬件的支持依赖较高，不同操作系统和硬件平台的实现方式可能不同。
- 在使用零拷贝技术时，需要注意数据的同步和一致性问题，避免数据出现错误或不一致的情况。

# IO多路复用

## 什么是IO多路复用技术

IO多路复用（IO Multiplexing）是一种操作系统提供的IO处理机制，通过同时监视多个文件描述符（FD）的IO状态，实现对这些IO事件的异步处理。常见的IO多路复用技术包括select、poll和epoll。

一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。我们熟悉的 select/poll/epoll 内核提供给用户态的多路复用系统调用，**进程可以通过一个系统调用函数从内核中获取多个事件**。select/poll/epoll 是如何获取网络事件的呢？在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。

## select/poll

select 实现多路复用的方式是，将已连接的 Socket 都放到一个**文件描述符集合**，然后调用 select 函数将文件描述符集合**拷贝**到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过**遍历**文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合**拷贝**回用户态里，然后用户态还需要再通过**遍历**的方法找到可读或可写的 Socket，然后再对其处理。

所以，对于 select 这种方式，需要进行 **2 次「遍历」文件描述符集合**，一次是在内核态里，一个次是在用户态里 ，而且还会发生 **2 次「拷贝」文件描述符集合**，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。

**select** 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 `1024`，只能监听 0~1023 的文件描述符。

**poll** 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。

但是 poll 和 select 并没有太大的本质区别，**都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合**，这种方式随着并发数上来，性能的损耗会呈指数级增长。

## epoll

epoll 通过两个方面，很好解决了 select/poll 的问题。

*第一点*，epoll 在内核里使用**红黑树来跟踪进程所有待检测的文件描述字**，把需要监控的 socket 通过 `epoll_ctl()` 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 `O(logn)`。而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。

*第二点*， epoll 使用**事件驱动**的机制，内核里**维护了一个链表来记录就绪事件**，当某个 socket 有事件发生时，通过**回调函数**内核会将其加入到这个就绪事件列表中，当用户调用 `epoll_wait()` 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。

从下图你可以看到 epoll 相关的接口作用：

![image-20230812151259074](D:\typora\Golang_Engineer\typora-user-images\image-20230812151259074.png)

epoll 的方式即使监听的 Socket 数量越多的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了，上限就为系统定义的进程打开的最大文件描述符个数。

### epoll性能为什么好

`epoll` 是 Linux 系统中一种高性能的事件通知机制，用于处理大量并发连接的网络编程。相比于其他传统的事件通知机制（如 `select` 和 `poll`），`epoll` 在处理大规模并发连接时具有更好的性能，主要有以下几个原因：

1. **高效的事件通知机制**：`epoll` 使用了事件驱动的方式，通过监听文件描述符上的事件来通知应用程序。它使用一个事件表来存储已注册的文件描述符和其对应的事件，当有事件发生时，只需要遍历事件表而不是遍历所有的文件描述符，从而减少了系统调用的次数，减轻了系统的负担。

2. **支持较大的并发连接数**：`epoll` 使用了基于红黑树的数据结构来维护事件表，这使得它可以高效地处理大量的并发连接。相比之下，`select` 和 `poll` 使用线性扫描的方式，每次都需要遍历整个文件描述符集合，其性能随着描述符数量的增加而下降。

3. **零拷贝技术**：`epoll` 支持零拷贝技术，可以避免在数据传输过程中多次拷贝数据。它使用了 `sendfile` 和 `splice` 等系统调用，将数据直接从文件系统缓冲区传输到网络缓冲区，减少了 CPU 的拷贝开销，提高了数据传输的效率。

4. **边缘触发模式**：`epoll` 提供了边缘触发模式（Edge Triggered，ET），在这种模式下，只有在文件描述符上的状态发生变化时才会通知应用程序，而不是在每个事件发生时都通知。这样可以避免应用程序在处理完一个事件后被频繁地重复通知，减少了不必要的上下文切换。

总的来说，`epoll` 在处理大规模并发连接时能够高效地利用系统资源，减少系统调用次数，提高数据传输效率，并且支持边缘触发模式，使得网络编程更加高效和易于管理。这些因素使得 `epoll` 的性能相对较好。

### epoll中的e是什么意思

在 `epoll` 中，"e" 代表 "event"，即事件。`epoll` 是基于事件驱动的机制，它通过监听文件描述符上的事件来通知应用程序。这些事件可以包括读取数据、写入数据、连接建立、连接关闭等等。

`epoll` 中的核心数据结构是 `epoll_event`，它定义了一个事件的结构，包含了文件描述符和事件类型等信息。在 `epoll` 中，我们可以注册一个或多个文件描述符，并指定所关注的事件类型。当某个文件描述符上的事件发生时，`epoll` 将通知应用程序，并提供相关的事件信息，应用程序可以根据事件类型进行相应的处理。

因此，"e" 在 `epoll` 中表示事件（event），它是 `epoll` 机制中的核心概念之一。

### 边缘触发和水平触发

epoll 支持两种事件触发模式，分别是**边缘触发（\*edge-triggered，ET\*）\**和\**水平触发（\*level-triggered，LT\*）**。这两个术语还挺抽象的，其实它们的区别还是很好理解的。

- 使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，**服务器端只会从 epoll_wait 中苏醒一次**，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；
- 使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，**服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束**，目的是告诉我们有数据需要读取；

如果使用水平触发模式，当内核通知文件描述符可读写时，接下来还可以继续去检测它的状态，看它是否依然可读或可写。所以在收到通知后，没必要一次执行尽可能多的读写操作。

如果使用边缘触发模式，I/O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会**循环**从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。所以，**边缘触发模式一般和非阻塞 I/O 搭配使用**，程序会一直执行 I/O 操作，直到系统调用（如 `read` 和 `write`）返回错误，错误类型为 `EAGAIN` 或 `EWOULDBLOCK`。

一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。

## 面试题

### 什么是IO多路复用技术

- IO多路复用是操作系统提供的一种IO处理机制，通过同时监视多个文件描述符（FD）的IO状态，实现对这些IO事件的异步处理。它可以在一个线程中处理多个IO事件，提高系统的性能和可扩展性。

### IO多路复用技术的用途

- IO多路复用技术主要用于实现高并发的网络编程。它可以同时监听多个网络连接的IO事件，一旦有IO事件发生，就可以立即进行处理，而不需要为每个连接创建一个线程或进程。

### select、poll和epoll区别。

- select是最早的IO多路复用技术，它使用位图来表示文件描述符的状态，支持的文件描述符数量有限，每次调用select都需要将所有的文件描述符从用户空间拷贝到内核空间。效率较低。**时间复杂度0(n)**
- poll是select的改进版本，它使用数组来表示文件描述符的状态，没有文件描述符数量的限制，但仍然需要将所有的文件描述符从用户空间拷贝到内核空间。时间复杂度0(n)
- epoll是Linux特有的IO多路复用技术，使用红黑树来管理文件描述符的状态，通过epoll_ctl和epoll_wait系统调用来管理和等待IO事件。它避免了将文件描述符从用户空间拷贝到内核空间的开销，具有更高的效率和可扩展性。时间复杂度0(1)

### select、poll和epoll优劣势及应用场景

select:
优势：**跨平台**：select是一个跨平台的I/O多路复用机制，可以在多个操作系统上使用。**简单易用**：select使用一个位图来表示文件描述符的状态，适用于简单的应用场景。

劣势：**低效**：在大量的文件描述符上进行监视时，select的效率会随着文件描述符数量的增加而下降。**文件描述符数量限制**：select的文件描述符数量有限，通常在1024左右。

场景：select适用于较小规模的应用或需要跨平台的应用。它是比较早期的I/O多路复用技术，可以在多个操作系统上使用。select适合于文件描述符数量较少（通常在1024左右）和并发连接数较少的场景

poll:
优势：**跨平台**：poll同样是一个跨平台的I/O多路复用机制，可以在多个操作系统上使用。**没有文件描述符数量限制**：相较于select，poll没有文件描述符数量的限制。

劣势：**低效**：poll在大量的文件描述符上进行监视时，效率也会随着文件描述符数量的增加而下降。

场景：poll是select的改进版本，同样适用于较小规模的应用或需要跨平台的应用。与select相比，poll没有文件描述符数量的限制，可以处理更多的文件描述符。因此，当需要处理的文件描述符数量较多时，可以选择使用poll。

epoll:
优势：高效：epoll使用红黑树来管理文件描述符的状态，通过epoll_ctl和epoll_wait系统调用来管理和等待IO事件。它避免了将所有文件描述符从用户空间拷贝到内核空间的开销，具有更高的效率和可扩展性。**没有文件描述符数量限制**：与select和poll不同，epoll没有文件描述符数量的限制。**支持边缘触发（Edge Triggered）模式**：epoll可以以边缘触发模式工作，只在状态变化时通知应用程序，避免了频繁的事件通知。

劣势：**仅适用于Linux系统**：epoll是Linux特有的I/O多路复用机制，不可跨平台使用。

场景：epoll是Linux特有的I/O多路复用技术。它使用红黑树和哈希表来管理文件描述符的状态，具有更高的效率和可扩展性。epoll适用于需要处理大规模并发连接的高性能应用场景，特别是在Linux环境下。它可以处理成千上万的并发连接，并具有更高的性能和可扩展性。

需要注意的是，选择适当的I/O多路复用方式取决于应用程序的需求和特性。对于较小规模的应用或需要跨平台的应用，select和poll是可行的选择。而对于高性能、大规模的应用，特别是在Linux环境下，epoll是更好的选择。

### 在使用IO多路复用技术时，什么是阻塞模式和非阻塞模式

- 阻塞模式指的是当没有IO事件发生时，IO操作会一直阻塞，直到有IO事件发生才会返回结果。而非阻塞模式下，当没有IO事件发生时，IO操作会立即返回，应用程序可以继续执行其他任务。

### IO多路复用技术与多线程、多进程方式相比，有何优劣势？

- 优势：IO多路复用技术可以节省系统资源，减少线程或进程的创建和切换开销，提高系统的性能和可扩展性。它可以在一个线程中处理多个IO事件，减少了线程之间的竞争和同步开销。
- 劣势：相比于多线程、多进程方式，IO多路复用技术的编程模型更复杂一些，需要手动管理和处理多个IO事件的状态和数据。

### **阻塞I/O、非阻塞I/O和I/O多路复用的区别**

- 阻塞I/O：当应用程序进行I/O操作时，会一直等待直到操作完成。
- 非阻塞I/O：应用程序发起I/O操作后，可以继续执行其他任务，然后定期检查操作是否完成。
- I/O多路复用：通过一种机制，一个线程可以同时监视多个I/O操作，只有当至少一个操作就绪时，线程才会被唤醒。

### epoll模式下，水平触发和边缘触发区别

在epoll模式下，水平触发（Level Triggered）和边缘触发（Edge Triggered）是两种不同的事件通知机制。

水平触发（Level Triggered）：
- 在水平触发模式下，当某个文件描述符上有事件就绪时，epoll_wait会立即返回该文件描述符，并通知应用程序进行IO操作。如果应用程序没有立即处理该事件，下次调用epoll_wait时仍会返回该文件描述符，直到该事件被处理完毕。

边缘触发（Edge Triggered）：
- 在边缘触发模式下，当某个文件描述符上有事件就绪时，epoll_wait只会通知应用程序一次。如果应用程序没有立即处理该事件，下次调用epoll_wait时不会再次返回该文件描述符，除非有新的事件就绪。边缘触发模式只关注状态的变化，而不关心当前状态。

边缘触发模式相比水平触发模式具有更高的效率和更精确的事件通知。在边缘触发模式下，应用程序需要及时处理事件，否则可能会错过事件通知。而在水平触发模式下，即使应用程序没有立即处理事件，下次调用epoll_wait时仍会返回该文件描述符。

需要注意的是，边缘触发模式需要应用程序处理完整的事件，包括读取所有可读数据或写入所有可写数据。而水平触发模式下，应用程序只需要处理当前就绪的事件，不需要读取或写入所有可读或可写的数据。

选择使用水平触发模式还是边缘触发模式取决于应用程序的需求和特性。通常情况下，边缘触发模式可以提供更高的性能，但需要确保应用程序能够及时处理所有事件。而水平触发模式相对更容易处理，适用于一些特定的应用场景。

# 5种网络IO模型

操作系统的五种网络IO模型包括：阻塞IO、非阻塞IO、IO多路复用、信号驱动IO和异步IO。下面详细介绍这五种模型：

1. **阻塞IO（Blocking IO）：**
   - 在此模型中，用户进程在发起IO请求后，会一直等待直到数据准备好并且被复制到用户空间缓冲区。在此期间，用户进程被阻塞，无法执行其他任务。
   - 阻塞IO是最简单的IO模型，但效率较低，因为它浪费了大量的CPU时间片在等待数据上。

原理：用户进程发起IO请求后，如果数据未准备就绪，该进程就会被操作系统挂起，直到数据准备好并且被复制到用户进程的缓冲区中，用户进程才继续执行。在等待数据期间，进程不执行任何计算或IO操作。

2. **非阻塞IO（Non-Blocking IO）：**

- 非阻塞IO允许用户进程在发起IO请求后立即返回，而不必等待数据准备好。用户进程可以定期检查数据是否准备好，或者当数据准备好时，系统会通知用户进程。
- 非阻塞IO提高了CPU的利用率，但增加了用户进程的复杂性，因为用户进程需要不断地轮询检查数据状态。

原理：用户进程发起IO请求后，如果数据未准备好，该请求会立即返回一个错误，而不是阻塞进程。用户进程需要不断地发起IO请求，直到数据准备好为止。非阻塞IO允许进程在等待数据的同时执行其他任务。

3. **IO多路复用（IO Multiplexing）：**

- IO多路复用允许用户进程同时监控多个IO事件（如多个socket连接）。当其中一个或多个IO事件就绪时，用户进程会被通知进行处理。
- 常见的IO多路复用技术有select、poll和epoll（主要在Linux中使用）。这些技术通过单个线程或进程监控多个文件描述符，提高了系统的并发处理能力。

原理：用户进程首先将要监控的IO操作添加到select或poll等系统调用中，然后阻塞在这些系统调用上。当有一个或多个IO操作准备好时，select或poll等系统调用返回，用户进程再逐个处理这些已准备好的IO操作。IO多路复用允许单个进程或线程同时监控多个IO事件，提高了系统的并发处理能力。

4. **信号驱动IO（Signal-Driven IO）：**

- 在信号驱动IO模型中，当数据准备好时，系统会发送一个信号给用户进程。用户进程在接收到信号后，可以处理数据。
- 信号驱动IO模型减少了用户进程的轮询次数，但增加了信号处理的复杂性。此外，由于信号在不同操作系统和平台上的实现可能存在差异，因此这种模型的可移植性较差。

原理：用户进程发起IO请求后，可以继续执行其他任务。当数据准备好时，操作系统会发送一个信号给用户进程。用户进程在接收到信号后，处理数据。信号驱动IO利用了信号机制来实现异步通知，减少了进程的轮询次数。

5. **异步IO（Asynchronous IO）：**

- 异步IO模型是最高级的IO模型。在此模型中，用户进程发起IO请求后，可以继续执行其他任务。当数据准备好并被复制到用户空间缓冲区时，系统会通知用户进程进行处理。
- 异步IO模型充分利用了CPU和IO资源，提高了系统的并发处理能力和整体性能。然而，实现异步IO模型需要操作系统的支持，并且编程复杂度相对较高。

原理：用户进程发起IO请求后，可以继续执行其他任务。当数据准备好并被复制到用户进程的缓冲区时，操作系统会通知用户进程进行处理。异步IO实现了真正的异步操作，用户进程无需关心IO操作的具体过程，只需在数据准备好时处理即可。
