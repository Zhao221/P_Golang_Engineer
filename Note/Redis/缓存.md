# 缓存雪崩

**大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机**时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是**缓存雪崩**的问题

## 发生场景

- 大量数据同时过期；
- Redis 故障宕机；

## 解决方案

- 均匀设置过期时间；

如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，**给这些数据的过期时间加上一个随机数**，这样就保证数据不会在同一时间过期。

- 互斥锁；

当业务线程在处理用户请求时，**如果发现访问的数据不在 Redis 里，就加个互斥锁**，保证同一时间内只有一个请求来构建缓存，实现互斥锁的时候，还要加上超时时间。 

- 后台更新缓存；

业务线程不再负责更新缓存，缓存也不设置有效期，而是**让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新**。

* 缓存失效时间分散：在设计缓存时，应该尽量避免大量缓存同时失效。可以通过随机化缓存失效时间、使用缓存失效时间递增等方式，将缓存失效时间分散，避免大量请求同时到达后端数据库。
* 缓存预热：在系统启动时，将热点数据加载到缓存中，避免在系统运行时进行缓存的构建。可以通过定时任务、系统启动时加载等方式实现缓存预热。
* 互斥锁控制：在高并发场景下，为了避免大量的请求同时到达存储层查询数据、重建缓存，可以使用互斥锁控制。当缓存层为命中时，对 key 加锁，然后从存储层查询数据，将数据写入缓存层，最后释放锁。若其他线程发现获取锁失败，则让线程休眠一段时间后重试。
* 异步重建缓存：在缓存失效后，可以异步地重建缓存。从线程池中获取线程来异步构建缓存，从而不会让所有的请求直接到达存储层。该方案中每个Redis key 维护逻辑超时时间，当逻辑超时时间小于当前时间时，则说明当前缓存已经失效，应当进行缓存更新，否则说明当前缓存未失效，直接返回缓存中的 value 值。
* 限流降级：无论是缓存层还是存储层都会有出错的概率，可以将它们视为资源。在缓存雪崩发生时，可以通过限流降级组件限制对后端数据库的访问，减轻数据库压力。
* 保持缓存层的高可用性：使用Redis 哨兵模式或者Redis 集群部署方式，即便个别Redis 节点下线，整个缓存层依然可以使用。

## 针对Redis宕机的缓存雪崩解决方案

- 服务熔断或请求限流机制；

我们可以启动**服务熔断**机制，**暂停业务应用对缓存服务的访问，直接返回错误**，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。为了减少对业务的影响，我们可以启用**请求限流**机制，**只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务**，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。

- 构建 Redis 缓存高可靠集群；

服务熔断或请求限流机制是缓存雪崩发生后的应对方案，我们最好通过**主从节点的方式构建 Redis 缓存高可靠集群**。如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。

# 缓存击穿

## 发生场景

- **热点数据过期：** 当某个热点数据的缓存过期时，如果此时有大量请求访问这个热点数据，缓存失效的瞬间可能会导致大量请求直接访问数据库。

- **并发访问：** 当多个并发请求同时访问一个缓存中不存在但在数据库中存在的数据时，如果没有合适的互斥机制，会导致这些请求都落到数据库上。

如果缓存中的**某个热点数据过期**了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是**缓存击穿**的问题。

## 解决方案

- 互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。
- 不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；
- 使用互斥锁：当缓存失效时，使用互斥锁来保证只有一个线程可以查询数据库，其他线程等待该线程将数据写入缓存后，再从缓存中获取数据。这种方式可以避免对数据库的并发访问，但可能会影响查询性能。
- 缓存预热：在系统启动时，将热点数据加载到缓存中，避免在系统运行时进行缓存的构建。可以通过定时任务、系统启动时加载等方式实现缓存预热。
- 逻辑过期策略：对于某些热点数据，即使设置了过期时间，也可能会发生缓存击穿的情况。可以采用逻辑过期策略，即在数据过期后，不是立即从缓存中删除该数据，而是将其置为另一种状态或值，以避免缓存击穿的发生。
- 分布式锁：当并发量非常大时，可以使用分布式锁来保证对数据库的并发访问。通过分布式锁来控制对数据库的访问，可以避免多个线程同时访问数据库，从而避免对数据库造成过大的压力。

# 缓存穿透

当用户访问的数据，**既不在缓存中，也不在数据库中**，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是**缓存穿透**的问题

## 发生场景

- 业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；
- 黑客恶意攻击，故意大量访问某些读取不存在数据的业务；

## 解决方案

- 第一种方案，非法请求的限制；

在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。

- 第二种方案，缓存空值或者默认值；
- 第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在；

## 布隆过滤器

布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。

布隆过滤器会通过 3 个操作完成标记：

- 第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；
- 第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。
- 第三步，将每个哈希值在位图数组的对应位置的值设置为 1；

当查询数据时，只要有一个位置对应的值为0，就认为不在数据库中。**查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据**。

# 数据库和缓存数据一致性

先更新数据库，再更新缓存会出现数据不一致的现象

先更新缓存，再更新数据库也会出现数据不一致的现象

先删除缓存，再更新数据库还是会出现数据不一致的现象

先更新数据，再删除缓存：缓存的写入通常远远快于数据库的写入









