# 设计模式六大原则

1. 单一职责原则
2. 里氏替换原则
3. 依赖倒转原则
4. 接口隔离原则
5. 迪米特法则
6. 开闭原则

#  **什么是设计模式**

设计模式（Design Patterns）是软件开发中一种经过实践验证的、可复用的、解决特定问题的优秀解决方案。设计模式在软件开发领域已经被广泛应用，它们提供了一种更加高效、可扩展、可维护的编程方法，有助于提高代码的质量和可读性。

设计模式的核心思想是提取和封装经常出现的问题和解决方案，使得设计者可以在新的情境中快速地应用已有的经验，从而更高效地解决问题。设计模式通常包含以下几个部分：

- **名称**：每个设计模式都有一个唯一的名称，用于描述其作用和用途。
- **问题**：设计模式旨在解决的特定问题或问题集合。
- **解决方案**：设计模式提供的核心解决方案和原理，用于解决问题。
- **实现**：设计模式的具体实现，包括类、接口和方法等。
- **示例**：设计模式的应用示例，通常包括代码示例。

设计模式可以根据其目的和作用范围分为三大类：

1. **创建型模式**（Creational Patterns）：这类模式关注对象的创建过程，提供了一种在不直接使用构造函数的情况下创建对象的方法。常见的创建型模式有：单例模式（Singleton）、工厂方法模式（Factory Method）、抽象工厂模式（Abstract Factory）、建造者模式（Builder）和原型模式（Prototype）。

2. **结构型模式**（Structural Patterns）：这类模式关注对象和类的组合方式，提供了一种将对象和类组合成更大的结构的方法。常见的结构型模式有：适配器模式（Adapter）、桥接模式（Bridge）、组合模式（Composite）、装饰器模式（Decorator）、外观模式（Facade）、享元模式（Flyweight）和代理模式（Proxy）。

3. **行为型模式**（Behavioral Patterns）：这类模式关注对象之间的通信和协作，提供了一种在对象之间实现通信和协作的方法。常见的行为型模式有：责任链模式（Chain of Responsibility）、命令模式（Command）、解释器模式（Interpreter）、迭代器模式（Iterator）、中介者模式（Mediator）、备忘录模式（Memento）、观察者模式（Observer）、状态模式（State）、策略模式（Strategy）、模板方法模式（Template Method）和访问者模式（Visitor）。

了解和掌握这些设计模式有助于开发者在软件开发过程中遇到问题时，能够迅速地应用已有的经验和解决方案，提高编程效率和代码质量。

# **设计模式各分类中模式的关键点**

## **创建型模式**

1. 单例模式（Singleton）：确保一个类只有一个实例，并提供一个全局访问点。
2. 工厂方法模式（Factory Method）：定义一个接口用于创建对象，但让子类决定实例化哪个类。工厂方法让类的实例化推迟到子类。
3. 抽象工厂模式（Abstract Factory）：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体的类。
4. 建造者模式（Builder）：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。
5. 原型模式（Prototype）：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

## **结构型模式**

1. 适配器模式（Adapter）：将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的类可以一起工作。
2. 桥接模式（Bridge）：将抽象部分与实现部分分离，使它们可以独立地变化。
3. 组合模式（Composite）：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
4. 装饰器模式（Decorator）：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式比生成子类更为灵活。
5. 外观模式（Facade）：提供了一个统一的接口，用来访问子系统中的一群接口。外观模式定义了一个高层接口，这个接口使得子系统更加容易使用。
6. 享元模式（Flyweight）：运用共享技术有效地支持大量细粒度的对象。
7. 代理模式（Proxy）：为其他对象提供一种代理以控制对这个对象的访问。

## **行为型模式**

1. 责任链模式（Chain of Responsibility）：为解除请求的发送者和接收者之间耦合，而使多个对象都有可能接收请求，将这些对象连接成一条链，并沿着这条链传递请求，直到有对象处理它为止。
2. 命令模式（Command）：将一个请求封装为一个对象，从而使用户可以用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。
3. 解释器模式（Interpreter）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
4. 迭代器模式（Iterator）：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。
5. 中介者模式（Mediator）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
6. 备忘录模式（Memento）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。
7. 观察者模式（Observer）：定义对象之间的一种一对多的依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。
8. 状态模式（State）：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。
9. 策略模式（Strategy）：定义一系列的算法，把它们一个个封装起来，并且使它们可互相替换。本模式使得算法可独立于使用它的客户而变化。
10. 模板方法模式（Template Method）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
11. 访问者模式（Visitor）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

了解这些设计模式的关键点有助于开发者在实际开发过程中判断何时使用哪种模式，并根据具体问题选择合适的模式来提高编程效率和代码质量。