## go link

在Go语言中，"link"通常用于表示链接器（linker）的概念。链接器是一个编译器工具，用于将多个目标文件（object file）合并为一个可执行文件或共享库。链接器负责解析符号引用，将不同目标文件中的符号关联起来，并生成最终的可执行代码。

链接器执行以下主要任务：

1. 符号解析：链接器会解析目标文件中的符号引用，找到对应的符号定义。符号可以是函数、变量或其他标识符。
2. 符号关联：链接器将不同目标文件中的符号引用与符号定义关联起来，以确保它们在程序执行时能够正确地被调用或访问。
3. 符号重定位：由于目标文件中的符号地址是相对于各自目标文件的起始地址的偏移量，链接器需要进行符号重定位，将符号引用的地址调整为最终可执行文件中的正确地址。
4. 生成可执行文件：链接器将经过符号关联和重定位后的目标文件合并为一个可执行文件，该文件包含了所有符号的正确地址和代码。

在Go语言中，链接过程通常由Go编译器自动完成。当我们使用`go build`或`go install`命令编译Go程序时，编译器会自动调用链接器来生成可执行文件或包。

## 在defer中修改return里面的值

在Go语言中，`defer`语句中的代码在函数返回之前执行，但是无法直接修改`return`语句中的返回值。当函数执行到`return`语句时，返回值已经被确定，并且`defer`语句中的代码无法改变它们。

如果你希望能够在`defer`语句中间接地修改返回值，你可以使用**具名返回值**（named return values）和**匿名函数**的组合。通过将返回值命名并在匿名函数中修改它们，你可以实现在`defer`语句中修改返回值的效果。以下是一个示例代码：

```go
package main

import "fmt"

func modifyReturnValue() (result int) {
	defer func() {
		result = result * 2 // 在defer中修改返回值
	}()

	result = 42 // 设置返回值
	return result
}

func main() {
	value := modifyReturnValue()
	fmt.Println(value) // 输出: 84
}
```

在上面的代码中，我们使用具名返回值`result`来表示函数的返回值。然后，在`defer`语句中的匿名函数中修改`result`的值。这样，在函数执行到`return`语句时，`result`的最终值会被返回。

运行上述代码，你会看到最终输出的结果是84，说明在`defer`语句中成功地修改了返回值。

需要注意的是，在使用具名返回值和`defer`语句修改返回值时，你需要确保匿名函数中对返回值的修改逻辑是正确的，并且不会引发意外的副作用。同时，也要注意具名返回值的初始化和赋值顺序，以确保返回值在`defer`语句执行之前已经被正确设置。

## 写入channel的时候，先判断阻不阻塞再写?

在Go语言中，向一个通道（channel）写入数据时会根据通道的状态来确定是否阻塞。如果通道是无缓冲的，并且没有其他goroutine正在读取该通道，写入操作将会阻塞，直到有其他goroutine进行读取操作。如果通道是有缓冲的，并且缓冲区未满，写入操作将不会阻塞；否则，写入操作会阻塞直到有空间可用。

你可以使用`select`语句结合通道的特性来判断写入操作是否会阻塞。`select`语句用于在多个通道操作中进行选择，可以用于判断通道的状态。以下是一个示例代码：

```go
package main

import "fmt"

func main() {
	ch := make(chan int, 1) // 创建一个有缓冲的通道

	select {
	case ch <- 42: // 尝试写入通道
		fmt.Println("写入成功")
	default:
		fmt.Println("写入阻塞")
	}
}
```

在上面的代码中，我们创建了一个有缓冲的通道`ch`，容量为1。然后使用`select`语句来尝试向通道写入数据。如果通道中有足够的空间，写入操作将会成功；否则，会执行`default`分支，表示写入操作被阻塞。

运行上述代码，你会看到输出结果为"写入成功"或"写入阻塞"，取决于通道的状态。

需要注意的是，`select`语句是非阻塞的，它会立即执行可执行的分支，如果没有可执行的分支，它将会阻塞等待。因此，在这个示例中，我们使用了`default`分支来判断写入操作是否被阻塞。

总结来说，你可以使用`select`语句结合通道的特性来判断写入操作是否会阻塞，从而根据需要进行相应的处理。

## mutex 是悲观锁

在Go语言中，`sync.Mutex`是一种悲观锁（pessimistic lock）。悲观锁假设会有并发的修改，因此在访问共享资源之前，它会阻塞其他goroutine的访问，确保当前goroutine能够独占地访问资源。

`sync.Mutex`是Go语言标准库中提供的一种互斥锁。通过调用`Lock`方法来获取锁，以确保只有一个goroutine能够进入被保护的临界区。在临界区内，对共享资源的访问是安全的。当完成对共享资源的操作后，需要调用`Unlock`方法来释放锁，以便其他goroutine可以获取到锁并继续执行。

以下是一个示例，展示了如何在Go语言中使用`sync.Mutex`：

```go
package main

import (
	"fmt"
	"sync"
)

var (
	counter int
	mutex   sync.Mutex
)

func increment() {
	mutex.Lock()
	defer mutex.Unlock()

	counter++
}

func main() {
	var wg sync.WaitGroup

	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			increment()
		}()
	}

	wg.Wait()

	fmt.Println("Counter:", counter)
}
```

在上述代码中，我们定义了一个全局的`counter`变量和一个互斥锁`mutex`。在`increment`函数中，我们使用`mutex.Lock()`来获取锁，确保只有一个goroutine能够进入临界区，执行`counter++`操作。在函数末尾使用`mutex.Unlock()`来释放锁。

在`main`函数中，我们启动了多个goroutine来并发地调用`increment`函数，每个goroutine都会对`counter`进行递增操作。通过使用互斥锁，我们保证了对`counter`的并发访问的安全性。

因此，`sync.Mutex`是一种悲观锁，它通过阻塞其他goroutine的访问来确保临界区的独占性，从而保护共享资源的一致性。

## 需要知道goroutine的一个函数是否执行成功

在Go语言中，可以使用**错误返回值**的方式来表示函数执行成功或失败，并在调用函数时对返回的错误进行处理。通常，一个函数会返回一个结果以及一个错误值，如果函数执行成功，错误值为`nil`，否则，错误值会包含相应的错误信息。

以下是一个示例代码，展示了如何在一个goroutine中执行函数并检查其执行成功与否：

```go
package main

import (
	"fmt"
	"errors"
)

func doSomething() error {
	// 模拟执行一些操作
	// 如果操作失败，则返回一个错误
	return errors.New("执行操作失败")
}

func main() {
	ch := make(chan error)

	go func() {
		err := doSomething()
		ch <- err // 将错误值发送到通道
	}()

	err := <-ch // 从通道接收错误值
	if err != nil {
		fmt.Println("函数执行失败:", err)
	} else {
		fmt.Println("函数执行成功")
	}
}
```

在上面的代码中，我们定义了一个`doSomething`函数，它模拟执行一些操作，并在操作失败时返回一个错误。在`main`函数中，我们创建了一个通道`ch`，并启动了一个goroutine来执行`doSomething`函数并将返回的错误值发送到通道。然后，我们从通道中接收错误值，并根据其是否为`nil`来判断函数的执行成功与否。

如果`doSomething`函数执行成功，它会返回`nil`的错误值，我们会输出"函数执行成功"的信息。如果函数执行失败，错误值不为`nil`，我们会输出"函数执行失败"并打印错误信息。

通过使用通道来接收错误值，我们可以在goroutine中获取函数执行的结果，并在主函数中进行相应的处理。

需要注意的是，在实际应用中，你可能会根据具体需求对错误进行更复杂的处理，例如记录日志、返回错误信息给调用者等。以上示例仅为了演示如何获取一个goroutine中函数的执行结果。

## 查找字符串子串，有什么算法

在计算机科学中，有几种常见的算法用于查找字符串子串。以下是其中几种常见的算法：

1. 暴力法（Brute Force）：也称为朴素字符串匹配算法，它是最简单直接的方法。它通过逐个比较主串和子串的字符来查找匹配。时间复杂度为O(n*m)，其中n是主串长度，m是子串长度。
2. KMP算法：Knuth-Morris-Pratt算法利用了在匹配过程中已经比较过的字符的信息，避免重复的比较。它利用一个部分匹配表（Partial Match Table）来记录子串中的前缀和后缀的最长公共部分。时间复杂度为O(n+m)，其中n是主串长度，m是子串长度。
3. Boyer-Moore算法：Boyer-Moore算法是一种启发式的字符串匹配算法。它从右到左比较主串和子串的字符，并根据预先计算的坏字符规则和好后缀规则来进行跳跃式的匹配。Boyer-Moore算法通常具有较好的性能，尤其在模式串较长且字符集较大时。时间复杂度为O(n+m)，其中n是主串长度，m是子串长度。
4. Rabin-Karp算法：Rabin-Karp算法是一种基于哈希的字符串匹配算法。它通过计算主串和子串的哈希值来进行匹配，从而避免逐个字符的比较。如果哈希值匹配，还需要进一步比较字符以排除哈希冲突。时间复杂度为O(n+m)，其中n是主串长度，m是子串长度。

这些算法各有优劣，适用于不同的场景。在实际应用中，选择合适的算法取决于字符串的长度、模式的特点以及性能需求等因素。

## json和protobuf的区别

JSON（JavaScript Object Notation）和Protobuf（Protocol Buffers）是两种常见的数据序列化和传输格式，它们有一些区别：

1. 数据格式：JSON是一种文本格式，使用可读性较好的键值对表示数据。它是一种人类可读的格式，易于理解和调试。而Protobuf是一种二进制格式，使用紧凑的编码方式表示数据。它的主要目标是提供高效的序列化和传输性能。

2. 数据大小：由于Protobuf使用二进制编码，相对于JSON，它可以产生更小的数据大小。这使得Protobuf在网络传输和存储上占用更少的带宽和磁盘空间。

3. 性能：由于Protobuf使用紧凑的二进制编码，它通常比JSON具有更高的性能。Protobuf的编/解码速度更快，并且在序列化和反序列化大型数据结构时，通常比JSON更高效。

4. 可扩展性：Protobuf具有更好的可扩展性。它支持版本化、字段添加和删除等操作，而不会破坏向后兼容性。这使得在更新数据结构时更加灵活。

5. 语言支持：JSON是一种通用的数据交换格式，在几乎所有编程语言中都有良好的支持。相比之下，Protobuf在某些编程语言中的支持可能相对较少，但仍然有广泛的语言支持，并且可以使用自动生成的代码来进行序列化和反序列化操作。

6. 可读性和可调试性：由于JSON是一种文本格式，它对人类来说更加可读和易于调试。你可以直接查看和编辑JSON数据。而Protobuf是一种二进制格式，不易于直接查看和编辑。

综上所述，JSON适合在人类可读性和易用性方面进行数据交换，而Protobuf则适合在性能、数据大小和可扩展性方面进行高效的数据传输和存储。选择使用哪种格式取决于具体的需求和场景。