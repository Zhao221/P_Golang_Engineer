# 查看进程的状态

在 Linux 系统中，可以使用 `ps` 命令来查看进程状态。`ps` 命令提供了多种选项，可用于显示不同类型的进程信息。以下是一些常用的 `ps` 命令选项：

1. `ps -e`：显示所有进程。
2. `ps -ef`：显示所有进程，以全格式输出。
3. `ps -u [username]`：显示指定用户的进程。
4. `ps -aux`：显示所有进程，包括其他用户的进程，输出更详细的信息。

要查看进程状态，可以使用 `ps -aux` 命令，它会显示详细的进程信息，其中 `STAT` 列表示进程状态。进程状态有以下几种：

1. `R`：运行状态（Running），进程正在运行或在运行队列中等待。
2. `S`：休眠状态（Sleeping），进程在等待某些条件满足，例如等待 I/O 完成或等待信号。
3. `D`：不可中断的休眠状态（Uninterruptible Sleep），进程在等待 I/O 完成，无法被信号中断。
4. `T`：暂停状态（Stopped），进程收到信号后暂停执行。
5. `Z`：僵尸状态（Zombie），进程已经终止，但其父进程尚未回收它的资源。

在终端中运行 `ps -aux` 命令，然后查看 `STAT` 列就可以找到对应进程的状态。如果你只对特定进程感兴趣，可以使用 `grep` 命令进行过滤，例如：

```bash
ps -aux | grep [process_name]
```

将 `[process_name]` 替换为你想要查看状态的进程名称。

# 查看全局日志文件

在 Linux 系统中，全局日志文件通常位于 `/var/log` 目录下。这些日志文件包含了系统和各种应用程序的运行信息，有助于诊断问题和了解系统状况。以下是一些常见的全局日志文件：

1. `/var/log/syslog` 或 `/var/log/messages`：这两个文件包含了系统的通用日志信息，例如内核、启动过程、系统服务和应用程序的日志。具体使用哪个文件取决于你的 Linux 发行版。Ubuntu 和 Debian 系统通常使用 `/var/log/syslog`，而 CentOS 和 RHEL 系统使用 `/var/log/messages`。

2. `/var/log/auth.log` 或 `/var/log/secure`：这两个文件包含了与认证和授权相关的日志信息，例如用户登录、sudo 命令执行等。Ubuntu 和 Debian 系统使用 `/var/log/auth.log`，而 CentOS 和 RHEL 系统使用 `/var/log/secure`。

3. `/var/log/kern.log`：这个文件包含了与内核相关的日志信息。

4. `/var/log/boot.log`：这个文件包含了系统启动过程的日志信息。

5. `/var/log/dmesg`：这个文件包含了系统启动时的内核缓冲信息。可以使用 `dmesg` 命令实时查看这些信息。

要查看这些日志文件，可以使用 `cat`、`less`、`tail` 等命令。例如，要查看 `/var/log/syslog` 文件，可以使用以下命令：

```bash
sudo less /var/log/syslog
```

如果你想实时查看日志文件的更新（例如，在调试程序时），可以使用 `tail -f` 命令：

```bash
sudo tail -f /var/log/syslog
```

此外，还有许多其他日志文件位于 `/var/log` 目录下，具体取决于你的系统和安装的应用程序。可以使用 `ls /var/log` 命令查看所有可用的日志文件。

## cat 、less、tail区别

- `cat`：用于显示整个文件内容。
- `less`：用于分页查看文件内容，可以在文件中上下滚动。
- `tail`：用于显示文件的最后几行内容，还可以实时显示文件更新。

# 查看服务器网络状态命令

在 Linux 系统中，有多个命令可以用来查看服务器的网络状态。以下是一些常用的命令：

1. `ifconfig`：`ifconfig` 命令用于显示和配置网络接口。它可以显示网络接口的 IP 地址、子网掩码、广播地址和 MAC 地址等信息。要使用 `ifconfig` 命令，只需在终端中输入：

```bash
ifconfig
```

注意：在一些新的 Linux 发行版中，`ifconfig` 命令已被 `ip` 命令取代。如果 `ifconfig` 命令不可用，可以尝试使用 `ip addr show` 命令。

2. `ip`：`ip` 命令是一个功能强大的网络配置工具。要查看网络接口信息，可以使用以下命令：

```bash
ip addr show
```

要查看路由表信息，可以使用以下命令：

```bash
ip route show
```

3. `netstat`：`netstat` 命令用于显示网络连接、路由表、接口统计等信息。要查看所有活动网络连接，可以使用以下命令：

```bash
netstat -a
```

要查看 TCP 和 UDP 端口的监听状态，可以使用以下命令：

```bash
netstat -tuln
```

4. `ss`：`ss` 命令（socket statistics）是一个功能类似于 `netstat` 的命令，但通常比 `netstat` 更快。要查看所有活动网络连接，可以使用以下命令：

```bash
ss -a
```

要查看 TCP 和 UDP 端口的监听状态，可以使用以下命令：

```bash
ss -tuln
```

5. `ping`：`ping` 命令用于测试与目标主机的网络连通性。要测试与目标主机（例如，www.example.com）的连通性，可以使用以下命令：

```bash
ping www.example.com
```

6. `traceroute` 或 `tracepath`：这两个命令用于显示数据包在网络中到达目标主机的路径。要使用 `traceroute` 命令，需要先安装它（例如，在 Ubuntu 和 Debian 系统中，使用 `sudo apt install traceroute` 命令安装）。然后，可以使用以下命令查看数据包的路径：

```bash
traceroute www.example.com
```

或者，使用 `tracepath` 命令（通常在 Linux 系统中默认安装）：

```bash
tracepath www.example.com
```

这些命令可以帮助你了解服务器的网络状态、连接情况和连通性。根据需要选择合适的命令。

## 查找文件地址

在Linux系统中，可以使用以下命令来查找文件的地址：

1. `find` 命令：`find` 命令用于在指定路径下递归地查找文件。它的基本语法如下：
   ````
   find <path> -name <filename>
   ```
   其中 `<path>` 是要查找的路径，`<filename>` 是要查找的文件名或通配符模式。这个命令将会在指定路径下递归地搜索文件，并输出文件的完整路径。
   
   例如，要在当前目录下查找名为 `example.txt` 的文件，可以运行以下命令：
   ````
   find . -name example.txt
   ```

2. `locate` 命令：`locate` 命令用于通过数据库快速查找文件。它会在预先建立的文件数据库中进行搜索，因此速度更快。使用 `locate` 命令的基本语法如下：
   ````
   locate <filename>
   ```
   这个命令会直接在数据库中查找与指定的文件名匹配的文件，并输出文件的路径。
   
   注意：为了保持数据库的最新状态，需要定期更新数据库，可以使用 `updatedb` 命令进行更新。
   
   例如，要查找名为 `example.txt` 的文件，可以运行以下命令：
   ````
   locate example.txt
   ```
   `locate` 命令是通过在预先建立的文件数据库中进行搜索来找到文件的。这个数据库通常由操作系统维护，并且会定期更新。然而，这也导致了一些限制和潜在的不准确性。
   
   下面是一些可能导致在使用 `locate` 命令时找不到文件的原因：
   
   1. 更新数据库的频率：`locate` 命令使用的文件数据库可能不是实时更新的。数据库通常会按照一定的时间间隔进行更新，这意味着在最新的文件创建或修改之后，数据库可能尚未包含这些信息。您可以使用 `updatedb` 命令手动更新数据库，或者等待系统根据预定的计划自动更新。
   
   2. 文件不在数据库中：`locate` 命令只能找到已经存在于文件数据库中的文件。如果文件是最近创建的或添加的，但尚未出现在数据库中，那么 `locate` 命令将无法找到它。在这种情况下，您可以尝试使用 `find` 命令进行递归搜索，或者等待数据库更新。
   
   3. 权限限制：`locate` 命令通常需要适当的权限来访问文件系统和数据库。如果您没有足够的权限，那么 `locate` 命令可能无法访问某些文件或数据库，从而导致找不到文件。
   
   4. 搜索路径限制：`locate` 命令默认只搜索指定的路径或默认搜索路径。如果您没有提供正确的搜索路径，或者文件位于未包含在搜索路径中的位置，那么 `locate` 命令将无法找到文件。
   
   如果您遇到 `locate` 命令找不到文件的情况，建议您先确保数据库已经更新，并检查您的搜索路径和权限。如果问题仍然存在，您可以考虑使用其他命令或工具来查找文件，例如 `find` 命令或使用文件管理器来进行手动搜索。

这些命令可以根据文件名、路径、通配符等条件来查找文件，并提供文件的完整路径。选择适合您需求的命令来进行文件查找。

# 查看进程端口信息

在 Linux 中，可以使用 `lsof` 或者结合 `ps` 和 `netstat` 或 `ss` 命令来查看进程端口。以下是关于这些命令的简要说明：

1. 使用 `lsof` 命令：

`lsof`（list open files）命令是一个用于显示打开文件和相关进程的实用工具。在这种情况下，我们可以用它来查找正在监听端口的进程。要使用 `lsof` 命令，请在终端中输入：

```bash
sudo lsof -i -P -n
```

解释：

- `-i`：列出与 Internet 相关的文件。
- `-P`：以数字形式显示端口（而不是服务名）。
- `-n`：不执行地址到主机名的解析。

2. 结合 `ps` 和 `netstat` 或 `ss` 命令：

首先，使用 `netstat` 或 `ss` 命令查看网络连接。例如，使用 `netstat` 命令：

```bash
sudo netstat -tulnp
```

或使用 `ss` 命令：

```bash
sudo ss -tulnp
```

这些命令将显示监听状态的 TCP 和 UDP 端口以及相关进程的 PID。然后，可以使用 `ps` 命令查看进程详细信息。例如，如果进程 PID 为 12345，可以使用以下命令：

```bash
ps -aux | grep 12345
```

这将显示与 PID 为 12345 的进程相关的详细信息，包括命令、用户和 CPU 使用率等。

使用这些命令可以帮助你了解进程正在使用哪些端口。根据需要选择合适的命令。

# 查看端口占用

在 Linux 中，可以使用 `lsof`、`netstat` 或 `ss` 命令来查看端口占用情况。以下是关于这些命令的简要说明：

1. 使用 `lsof` 命令：

`lsof`（list open files）命令是一个用于显示打开文件和相关进程的实用工具。要查看特定端口（例如，端口 80）的占用情况，请在终端中输入：

```bash
sudo lsof -i :80
```

2. 使用 `netstat` 命令：

`netstat` 命令用于显示网络连接、路由表、接口统计等信息。要查看特定端口（例如，端口 80）的占用情况，请在终端中输入：

```bash
sudo netstat -tuln | grep :80
```

解释：

- `-t`：显示 TCP 端口。
- `-u`：显示 UDP 端口。
- `-l`：仅显示监听状态的端口。
- `-n`：以数字形式显示地址和端口（而不是使用域名和服务名）。
- `grep :80`：过滤结果，仅显示包含 ":80"（端口 80）的行。

3. 使用 `ss` 命令：

`ss` 命令（socket statistics）是一个功能类似于 `netstat` 的命令，但通常比 `netstat` 更快。要查看特定端口（例如，端口 80）的占用情况，请在终端中输入：

```bash
sudo ss -tuln | grep :80
```

解释：

- `-t`：显示 TCP 端口。
- `-u`：显示 UDP 端口。
- `-l`：仅显示监听状态的端口。
- `-n`：以数字形式显示地址和端口（而不是使用域名和服务名）。
- `grep :80`：过滤结果，仅显示包含 ":80"（端口 80）的行。

使用这些命令可以帮助你了解特定端口的占用情况。根据需要选择合适的命令。

# Linux常用命令

在Linux系统中，有许多常用的命令可以用于文件操作、系统管理、网络配置等等。以下是一些常见的Linux系统命令：

## **文件和目录操作**

- 列出文件和目录：`ls`
- 切换目录：`cd`
- 创建目录：`mkdir`
- 复制文件或目录：`cp`
- 移动文件或目录：`mv`
- 删除文件或目录：`rm`
- 查看文件内容：`cat`
- 编辑文件：`nano`, `vim`, `emacs`
- 查找文件：`find`
- 压缩文件：`tar`, `gzip`, `zip`

## **系统信息和状态**

- 查看系统信息：`uname -a`
- 查看进程列表：`ps`
- 查看系统负载：`top`
- 查看硬件信息：`lshw`, `lscpu`
- 查看内存使用情况：`free`
- 查看磁盘使用情况：`df`, `du`

## **用户和权限管理**

- 查看当前用户：`whoami`
- 切换用户：`su`
- 添加用户：`useradd`
- 修改用户密码：`passwd`
- 修改文件权限：`chmod`
- 修改文件所有者和组：`chown`, `chgrp`

## **网络配置和连接**

- 查看IP地址：`ifconfig`, `ip addr`
- 查看网络连接：`netstat`
- 远程连接：`ssh`
- 下载文件：`wget`, `curl`

## **包管理和软件安装**

- 更新软件包信息：`sudo apt update` (Ubuntu/Debian), `sudo yum update` (CentOS/RHEL)
- 安装软件包：`sudo apt install` (Ubuntu/Debian), `sudo yum install` (CentOS/RHEL)

## **进程管理**

- 杀死进程：`kill`
- 后台运行命令：`&`
- 后台运行命令并保持运行：`nohup`

## **定时任务**

- 创建定时任务：`crontab -e`
- 查看定时任务：`crontab -l`

## **系统管理**

- 重启系统：`reboot`
- 关闭系统：`shutdown`

## **用户交互**

- 提示输入：`read`

这只是一些常见的Linux命令，Linux系统提供了大量功能强大的命令行工具，可以满足各种系统管理、文件操作和网络配置的需求。根据具体的任务和场景，你可能需要深入了解更多命令和选项。

## CPU利用率

在 Linux 系统中，你可以使用以下几个命令来查看当前的 CPU 利用率：

1. **top 命令**：`top` 命令是一个交互式的实时进程监控工具，它可以显示系统的整体状态，包括 CPU 利用率。在终端中输入以下命令：

   ```
   cssCopy code
   top
   ```

   按下 `q` 键退出 `top` 命令。

2. **htop 命令**：`htop` 是 `top` 的一个交互式替代工具，提供了更多的功能和界面改进。你可以使用以下命令安装并运行 `htop`：

   ```
   csharpCopy codesudo apt-get install htop   # 适用于 Debian/Ubuntu 系统
   sudo yum install htop       # 适用于 CentOS/Fedora 系统
   htop
   ```

   按下 `q` 键退出 `htop` 命令。

3. **mpstat 命令**：`mpstat` 命令用于显示每个 CPU 的统计信息，包括 CPU 利用率。在终端中输入以下命令：

   ```
   Copy code
   mpstat
   ```

   按下 `Ctrl + C` 键来停止 `mpstat` 命令。

4. **sar 命令**：`sar` 命令用于系统性能监控和报告。你可以使用以下命令来安装并运行 `sar`：

   ```
   csharpCopy codesudo apt-get install sysstat   # 适用于 Debian/Ubuntu 系统
   sudo yum install sysstat       # 适用于 CentOS/Fedora 系统
   sar
   ```

   按下 `q` 键退出 `sar` 命令。

# IO原理

## **描述**

指在计算机执行操作时，CPU不需要先将数据从一个内存区域复制到另一个内存区域，从而减少上下文切换以及CPU的拷贝时间

## **作用**

它的作用是，在数据包从网络设备到用户程序空间的传递过程中，减少数据拷贝次数，减少系统调用，实现CPU零参与（DMA、内存映射技术）

## **网络数据传输过程**

1. 当http服务器收到来自浏览器的请求时，负责处理请求的线程发起系统调用，让内核将所需数据从存储设备加载到内核缓冲区kernel buffer（由于内存设备和存储设备之间没有数据传输，没有CPU参与，所以这次是DMA操作）
2. 当数据准备好后，内核唤醒处理请求的线程，让它使用read()函数把数据复制到应用缓冲区，到了应用缓冲区就属于该线程独有，可以对其进行读写操作
3. 当数据修改完成（也可能没做任何操作），通过write()函数将应用缓冲区中的数据复制到socket缓冲区的send buffer
4. 非本机的数据最终还是通过网卡传输出去的，所以再使用send()函数就可以将send buffer的数据发送给网卡（由于内存设备和存储设备之间没有数据传输，没有CPU参与，所以这次是DMA操作）

## **Linux IO数据传输过程**

* 第一阶段：等待数据放入内核空间
* 第二阶段：将数据从内核空间复制到用户空间

## **Linux IO读写方式**

1. 轮询：基于循环对IO端口不断检测
2. IO中断：当数据达到时，磁盘主动向CPU发起中断请求，由CPU自身负责数据传输过程，在DMA技术出现之前，应用程序与磁盘之间的IO请求都是通过CPU完成的，CPU中断然后发起IO请求，等待数据拷贝完成
3. DMA：直接内存存取，在IO中断的基础上引入DMA磁盘控制器，由DMA磁盘控制器负责数据的传输，降低CPU的资源消耗

## **Linux IO模型**

- 描述：所谓IO模型，描述的是出现IO等待时，进程的状态以及处理数据的方式
- 阻塞式IO（BIO）程序想要在缓冲区读数据时，缓冲区并不一定会有数据，这回造成陷入系统调用，只能等待，数据可以读取，没有数据读取时会阻塞住进程
- 非阻塞式IO（NIO）应用进程在发起IO系统调用（读取数据）后会立即返回，应用进程可以轮询发起IO系统调用，直到内核返回可以读取标识
- 多路IO复用：将多个应用进程的socket注册到多路复用器上，使用一个进程来监听该多路复用器，只要有一个socket的数据准备好就会返回该socket，再由应用进程发起IO系统调用，来完成数据读取（使用多路复用器来统一轮询，而不是每个进程进行轮询）
- 信号驱动IO：应用进程向内核注册一个信号处理程序，当内核中有数据准备好，会发送一个信号给应用进程，应用进程便可以在信号处理程序中发起IO系统调用，来完成数据读取（通过信号通知而不是轮询，避免了大量无效的数据状态轮询操作）
- 异步IO应用进程发起IO系统调用后，会立即返回，当内核中数据准备好并复制到用户空间后，会产生一个信号来通知应用进程只需发起一次系统调用，便可以完成对数据的读取

## 零拷贝技术

* 用户态直接IO：运行在用户态的库函数直接访问硬件设备，数据直接跨过内核进行传输，适用于不需要内核缓冲区处理的应用程序
* mmap+write：mmap是Linux提供的一种内存映射方法，即将一个进程的地址空间中的一段虚拟地址映射到磁盘文件地址，使用mmap的目的是将内核中读缓冲区的地址与用户空间的缓冲区进行映射，从而实现内核缓冲区与应用程序内存共享
* sendfile：sendfile系统调用可以将数据从文件描述符发送到另一个文件描述符，这个过程始终在内核空间，因此可以实现零拷贝
* sendfile+DMA gather copy：DMA引入了gather操作，使其可以根据内存地址、地址偏移量将数据批量从内核缓冲区拷贝至网卡，

sendfile只需将读缓冲区的文件描述符和数据长度拷贝至socket buffer，DMA通过gather操作直接读取内核缓冲区数据

* splice：splice系统调用在内核空间的读缓冲区和socket buffer之间建立管道，避免两者之间CPU拷贝操作

# CPU

## 中断

cpu运行过程中，当发生其他事件，cpu停止当前程序流，转而处理该事件

**软中断**

1. cpu指令，由当前运行程序产生
2. 系统调用：程序从用户态转为内核态；执行系统函数；程序从内核态返回用户态

**硬中断**

外设、磁盘、网卡、时钟：时钟周期：时钟频率的倒数，是计算机中最小的事件单位

## CPU架构

1. 控制器，运算器，寄存器，L1（数据缓存，指令缓存，L2）

寄存器：寄存器是cpu内部用于存放数据的小型存储区域，用来暂时存放参与运算的数据及结果，和一些cpu运行时需要的信息，通用寄存器、标志寄存器、指令寄存器、控制寄存器

2. L3，总线、主存、磁盘

## 缓存

* 局部性原理
  1. cpu在访问存储设备的时候，都趋于聚集在一片连续的区域中
  2. 时间局部性：如果一个信息项正在被访问，那么近期它可能倍再次访问
  3. 空间局部性：如果一个存储器的位置被引用，那么它附近的位置也可能将来被引用
* 缓存一致性协议

![image-20240216205339653](D:\typora\Golang_Engineer\typora-user-images\image-20240216205339653.png)

![image-20240216205402776](D:\typora\Golang_Engineer\typora-user-images\image-20240216205402776.png)

![image-20240216205439428](D:\typora\Golang_Engineer\typora-user-images\image-20240216205439428.png)

![image-20240216205506456](D:\typora\Golang_Engineer\typora-user-images\image-20240216205506456.png)

![image-20240216205518102](D:\typora\Golang_Engineer\typora-user-images\image-20240216205518102.png)

* 缓存行cache line
  1. CPU缓存中可分配的最小单元，与结构有关，常用64字节
  2. 伪共享：what：共享数据被修改，需从内存中重新加载，极大降低了CPU效率；how：缓存行填充（缓存行对齐）
  3. 多路组相联 Set Associativity：将缓存划分为若干个cacheline，将指定数量的cacheline关联成一个组
  4. 缓存淘汰机制：FIFO、LRU

## linux的CPU上下文切换

* 上下文：CPU在运行每个任务之前，都必须知道任务从哪里加载以及从哪里开始运行，这些都依赖于系统事先帮他设置好寄存器和程序计数器；CPU寄存器：CPU内置容量小、速度快的内存空间；程序计数器：用来存储即将执行的下一跳指令位置

* 上下文切换：将当前任务的上下文保存起来，然后加载新任务的上下文，运行新任务，这些保存的上下文，会存储在内核中，并在任务调度执行时再次加载进来

* CPU上下文切换类型

  1. 系统调用上下文切换：
     - 内核空间（Ring0）：具有最高权限，可以直接访问所有资源；
     - 用户空间（Ring3）：只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中才能访问这些特权资源；
     - CPU按照特权等级，把进程运行空间分为内核空间和用户空间，分别对应CPU特权等级的RIng0和Ring3；
     - 进程既可以在用户空间运行也可以在内核空间运行，进程在用户空间运行称为用户态，而陷入内核空间时，被称为内核态；
     - 从用户态到内核态的转变，需要通过系统调用来完成；
     - 系统调用过程中对用户的资源没有任何影响，也不会切换进程，所以也称为特权模式切换；
     - 系统调用会产生两次上下文切换，由于内核对用户的不信任，因此内核需要对用户进行一些额外的检查，这就耗费了更多的工作了
  2. 进程上下文切换

  进程的切换只能发送在内核态，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户资源，还包括了内核堆栈，寄存器等内核空间的状态；虚拟内存

  3. 线程上下文切换

  同进程中两个线程切换：因为虚拟内存共享，所以只需要切换线程的私有数据，寄存器等不共享的数据

  不同进程的两个线程切换：应为资源不共享，所以和进程上下文切换一样

  4. 中断上下文切换

与进程上下文不同，中断上下文切换并不设计进程的用户态，只包括内核态中断服务程序执行所必须的状态，包括寄存器、内核堆栈、硬件中断参数等
