# 实习经历

我在公司实习了两个月，在这两个月里我完成了以下几方面的工作：
1. 用一周的时间完成了以下工作：

    一、配置了go、redis、mysql、极狐的环境

    二、下载了公司常用软件例如：Goland、iTerm2、Navicat、Apifox等

    三、学习公司的开发规范、技术文档及常用工具的使用；

2. 第二周根据导师安排的任务，完成了单测以及接口自动化的任务

3. 圆满完成leader安排的公司项目梳理及串讲，并得到了leader的高度认可。此次串讲涉及到项目的背景和目标、功能和特点、技术架构、业务逻辑、API设计、数据库关联、并提出了一些问题等（此处请用更专业，更凸显串讲技术能力或者业务能力的语言来表述）；

4. 解决了公司业务中一个难度较大的历史遗留问题（用时一周）。（用时多久解决这个问题，这个要与你写的实习时间相匹配）
    解决这个问题分为五个步骤：
    一、在原来的业务逻辑上排查，找到问题所在，但因公司内部原因无法修复这个BUG;
    二、 积极与老员工及leader沟通，提出由我重构这部分代码，得到leader同意；
    三、设计代码业务逻辑，完成开发文档，组织项目组成员进行串讲；
    四、进入代码实现环节，完成开发并在导师的指导下进行代码优化（代码规范化）；
    五、测试上线；

5. 后续就趋于常规化了，就是正常得修改一些bug，写一些功能流程文档和接口对接文档啥的。

    注：在以上说实习经历过程中，或者说完后，面试官会问你问题，在说实习经历过程中一定留时间给面试官去问，问了你来详细解答，详细解决可用以下你写的来回答，但是不要加很多主官情感类的词语。（下班有时间找我聊，我给你说什么是主观情感）
    进入到公司后先熟悉公司环境，第一天的话就是配置一下环境（go，mysql，redis，极狐），下载公司常用的软件。之前用的都是windows，公司的电脑是Mac，还挺好用的，配置环境真简单。因为我是周五入职的，所以第一天的工作相对简单。然后后面就是leader让我对公司的项目做个串讲，串讲的话也是个技术活，因为串讲的主要目的是为了显示你对的项目的熟悉程度，这样导师才会放心安排工作。串讲的话主要是将项目目录分析一下，目录下都有哪些模块，这些模块都有哪些功能，对应的API都有什么？相应API的逻辑都有哪些，涉及的到数据库都有什么等等，需要讲的东西还不少。串讲完后，leader还是很满意的，然后就让导师给我找了个历史遗留问题，反作弊模块上报的图片获取不到，让我解决这个bug。然后我通过本地使用Apifox和查看阿里云日志库，将问题定位到最下游的服务挂了，图片没有处理，在上游是图片没有处理的都过滤掉了，所以查不到图片，然后因为写这个服务的人已经离职了，没有人会维护，于是leader决定采用阿里云人脸识别对比，让我重新写一个服务，接下来，就是设计自己的逻辑，写文档，让后把项目组的人聚集起来，进行串讲，串讲完后，leader说没啥问题，可以进入研发了，最后画了两天的时间，做出来了，让导师对我的代码进行code review，根据问题进行了修改，代码没啥问题，主要是规范，需要跟公司一样。最后进行测试，没啥问题，然后就上线了。大致就这么多

    # 笔试算法题

    ## 青蛙跳台阶

    青蛙可以选择跳上任意级台阶，即每一级台阶都有两种选择：跳或不跳。因此，对于n级台阶，总共的跳法数等于2的n-1次方。

    ```go
    package main
    
    import (
    	"fmt"
    )
    
    func jumpFloorII(n int) int {
    	if n <= 0 {
    		return 0
    	}
    	return 1 << (n - 1)
    }
    
    func main() {
    	n := 5
    	total := jumpFloorII(n)
    	fmt.Printf("对于 %d 级台阶，总共有 %d 种跳法。\n", n, total)
    }
    ```

    ## 匹配括号

    ```go
    package main
    
    import "fmt"
    
    func checkValidString(s string) bool {
    	// 使用两个栈分别存储左括号和星号的索引位置
    	var leftStack, starStack []int
    
    	for i, ch := range s {
    		if ch == '(' {
    			leftStack = append(leftStack, i)
    		} else if ch == '*' {
    			starStack = append(starStack, i)
    		} else {
    			// 遇到右括号时，优先与左括号匹配，若左括号栈非空，则出栈一个左括号
    			if len(leftStack) > 0 {
    				leftStack = leftStack[:len(leftStack)-1]
    			} else if len(starStack) > 0 {
    				// 若左括号栈为空，则与星号匹配，出栈一个星号
    				starStack = starStack[:len(starStack)-1]
    			} else {
    				// 若左括号栈和星号栈都为空，则无法匹配，返回false
    				return false
    			}
    		}
    	}
    
    	// 遍历完字符串后，开始匹配剩余的左括号和星号
    	for len(leftStack) > 0 && len(starStack) > 0 {
    		// 若星号的索引位置在左括号的后面，则无法匹配，返回false
    		if leftStack[len(leftStack)-1] > starStack[len(starStack)-1] {
    			return false
    		}
    		leftStack = leftStack[:len(leftStack)-1]
    		starStack = starStack[:len(starStack)-1]
    	}
    
    	// 若左括号栈为空，则表示所有左括号都得到了匹配
    	return len(leftStack) == 0
    }
    
    func main() {
    	s := "((*)"
    	isValid := checkValidString(s)
    	fmt.Println(isValid)
    }
    ```

    这段代码是用来判断一个字符串是否为合法的括号字符串。下面是对代码的详细介绍：

    1. `checkValidString` 函数定义了一个输入参数为字符串 `s`，返回值为布尔类型的函数。该函数用于判断字符串 `s` 是否为合法的括号字符串。

    2. 在函数内部，定义了两个空的整型切片 `leftStack` 和 `starStack`，用于存储左括号和星号的索引位置。

    3. 使用 `for` 循环遍历字符串 `s`，通过 `range` 关键字获取每个字符的索引和值。

    4. 判断当前字符 `ch` 的情况：
       - 若为左括号 `(`，则将当前索引 `i` 添加到 `leftStack` 中，表示找到一个左括号。
       - 若为星号 `*`，则将当前索引 `i` 添加到 `starStack` 中，表示找到一个星号。
       - 若为右括号 `)`，则进行匹配操作：
         - 若 `leftStack` 非空，则从 `leftStack` 中移除一个左括号，表示与当前右括号进行匹配。
         - 若 `leftStack` 为空且 `starStack` 非空，则从 `starStack` 中移除一个星号，表示将当前右括号视为与星号匹配。
         - 若 `leftStack` 和 `starStack` 都为空，则无法进行匹配，返回 `false`。

    5. 遍历完字符串后，开始匹配剩余的左括号和星号：
       - 若 `leftStack` 和 `starStack` 都非空，比较最后一个左括号的索引和最后一个星号的索引。若最后一个左括号的索引大于最后一个星号的索引，表示无法匹配，返回 `false`。
       - 若匹配成功，从 `leftStack` 和 `starStack` 中分别移除一个元素。

    6. 最后，检查 `leftStack` 是否为空。若为空，表示所有的左括号都得到了匹配，返回 `true`；否则，返回 `false`。

    7. 在 `main` 函数中，定义了一个字符串 `s`，并调用 `checkValidString` 函数来判断字符串是否为合法的括号字符串。将结果打印输出。

    总体来说，该代码通过使用两个栈来记录左括号和星号的索引位置，按照括号匹配的规则进行判断，最终确定字符串是否为合法的括号字符串。

## 冒泡排序

```go
package main

import "fmt"

func bubbleSort(arr []int) {
	n := len(arr)

	// 外层循环控制比较轮数
	for i := 0; i < n-1; i++ {
		// 内层循环进行相邻元素的比较和交换
		for j := 0; j < n-i-1; j++ {
			// 如果前面的元素比后面的元素大，则交换它们
			if arr[j] > arr[j+1] {
				arr[j], arr[j+1] = arr[j+1], arr[j]
			}
		}
	}
}

func main() {
	arr := []int{64, 34, 25, 12, 22, 11, 90}
	fmt.Println("原始数组:", arr)

	bubbleSort(arr)
	fmt.Println("排序结果:", arr)
}
```

步骤解释：

1. 定义了一个名为`bubbleSort`的函数，该函数接受一个整数切片作为参数。
2. 获取切片的长度并保存在变量`n`中。
3. 外层循环控制比较轮数，从第一轮比较到倒数第二轮（`n-1`次）。
4. 内层循环用于比较相邻元素并进行交换，每一轮的比较将会把当前最大的元素冒泡到切片的末尾。
5. 在内层循环中，使用变量`j`遍历切片，从索引0开始，直到`n-i-1`，因为每一轮比较都会将最大的元素冒泡到末尾，所以下一轮的比较次数会减少。
6. 在内层循环中，比较相邻的两个元素，如果前面的元素比后面的元素大，则交换它们的位置，确保较大的元素在后面。
7. 在主函数`main`中，定义一个初始数组`arr`，并打印出来。
8. 调用`bubbleSort`函数对切片`arr`进行排序。
9. 打印排序后的结果。

以上就是使用Go语言实现冒泡排序的代码，并对每个步骤进行了详细说明。冒泡排序的核心思想是通过相邻元素的比较和交换，逐渐将最大（或最小）的元素冒泡到末尾，重复这个过程直到整个序列有序。

## 链表是否相交

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    m := map[*ListNode]bool{}
    for temp:=headA;temp!=nil;temp=temp.Next{
        m[temp]=true
    }  
    for temp:=headB;temp!=nil;temp=temp.Next{
        if m[temp]{
            return temp
        }
    } 
    return nil
}
```

判断两个链表是否相交，可以使用哈希集合存储链表节点。

首先遍历链表headA，并将链表headA 中的每个节点加入哈希集合中。然后遍历链表headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：

如果当前节点不在哈希集合中，则继续遍历下一个节点；

如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表headB 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点。

如果链表headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回null。

# 网络安全相关的面试题

当面试涉及网络安全时，可能会问到以下一些常见问题和相应的答案：

## 什么是网络安全？
网络安全是指保护计算机系统、网络和数据免受未经授权的访问、损坏或窃取的过程。它涵盖了各种技术、措施和实践，旨在确保网络的机密性、完整性和可用性。

## 请解释下面几个常见的网络安全术语：防火墙、入侵检测系统（IDS）和入侵防御系统（IPS）。

- 防火墙：防火墙是一种网络安全设备，用于监控和控制网络流量，根据预定义的规则筛选和阻止不安全的网络连接。
- 入侵检测系统（IDS）：IDS监视网络流量和系统活动，检测潜在的入侵行为或安全事件。它会产生警报或通知管理员以采取适当的行动。
- 入侵防御系统（IPS）：IPS是一种主动的安全控制系统，可以监视网络流量并根据预定义的规则主动地阻止潜在的攻击或安全违规行为。

## 请列举一些常见的网络攻击类型。

- 电子邮件欺诈（例如钓鱼和垃圾邮件）
- 恶意软件（例如病毒、蠕虫、木马和勒索软件）
- DoS（拒绝服务）和DDoS（分布式拒绝服务）攻击
- 网络针孔攻击（如端口扫描和漏洞利用）
- 社交工程（通过欺骗人们获取敏感信息）
- 网络钓鱼（伪装成可信实体以获取敏感信息）
- 无线网络攻击（如Wi-Fi劫持和破解）

## 请说明密码安全性的几个重要方面。

- 密码复杂性：密码应包含足够的长度和多样性，包括大写字母、小写字母、数字和特殊字符。
- 密码安全性：密码应该是唯一的，不要重复使用，并且不要使用易于猜测的信息，如个人生日、名字等。
- 密码存储：密码应以加密的形式存储，最好使用哈希函数和盐值来保护密码。
- 密码更新：密码应定期更改，以防止长期的攻击和密码泄露。

## 请解释公钥加密和私钥加密的区别。

- 公钥加密：公钥加密使用一对密钥，即公钥和私钥。公钥用于加密数据，而私钥用于解密数据。公钥可以公开共享，任何人都可以使用公钥对数据进行加密，但只有私钥的持有者可以解密数据。
- 私钥加密：私钥加密也使用一对密钥，即私钥和公钥。私钥用于加密数据，而公钥用于解密数据。私钥是保密的，只有私钥的持有者可以使用私钥对数据进行加密，而任何人都可以使用公钥解密数据。

这些问题和回答仅作为参考，实际面试可能会因公司、职位和特定要求而有所不同。在准备面试时，还应了解公司的网络安全需求，并对相关技术和实践进行进一步研究。

以下是一些常见的网络攻击类型及相应的解决方案：

## DDoS 攻击（分布式拒绝服务攻击）
DDoS攻击旨在通过向目标服务器发送大量的请求来耗尽其资源，导致服务不可用。解决方案包括：

- 流量过滤和清洗：使用防火墙、入侵检测系统（IDS）和入侵防御系统（IPS）来过滤和清洗恶意流量。
- 负载均衡：使用负载均衡器来分散流量，确保服务器能够处理更多的请求。
- CDN（内容分发网络）：使用CDN来分发流量，减轻服务器的负载。

## 恶意软件攻击
恶意软件包括病毒、蠕虫、木马和勒索软件等，它们可能会感染系统、窃取信息或对系统进行破坏。解决方案包括：

- 防病毒软件：使用最新的防病毒软件来检测和清除恶意软件。
- 定期更新和补丁：确保操作系统和应用程序的补丁都是最新的，以修复已知的漏洞。
- 用户教育和安全意识培训：教育用户如何避免点击可疑链接、下载未知附件或访问不受信任的网站。

## 钓鱼攻击
钓鱼攻击通过伪装成可信实体（如银行、社交媒体等）来诱骗用户透露敏感信息，如用户名、密码、信用卡号等。解决方案包括：

- 用户教育和安全意识培训：教育用户如何识别和避免钓鱼邮件、短信和网站。
- 多因素身份验证：启用多因素身份验证，以增加账户的安全性。
- 防病毒软件和反钓鱼工具：使用防病毒软件和反钓鱼工具来检测和阻止钓鱼尝试。

## 网络针孔攻击
网络针孔攻击包括端口扫描、漏洞利用和拒绝服务攻击等，旨在获取未经授权的访问、窃取数据或破坏系统。解决方案包括：

- 防火墙和入侵检测系统（IDS）/入侵防御系统（IPS）：配置和管理防火墙，并使用IDS/IPS来检测和阻止网络针孔攻击。
- 补丁管理：及时应用操作系统和应用程序的安全补丁，修复已知漏洞。
- 安全配置：采用安全的网络配置，关闭不必要的服务和端口。

## 社交工程攻击
社交工程攻击利用人们的信任和社交工具（如电话、电子邮件、社交媒体）来获取敏感信息或进行欺骗。解决方案包括：

- 安全意识培训：教育用户关于社交工程攻击的常见手段和如何避免成为受害者。
- 多因素身份验证：启用多因素身份验证以增加账户的安全性。
- 安全策略和流程：建立安全策略和流程，确保员工知道如何处理可疑的请求或情况。

这些解决方案提供了一些常见网络攻击类型的基本对策，但请注意，网络安全是一个不断演变的领域，攻击者和攻击方法也在不断进化。因此，保持对最新的安全威胁和解决方案的了解非常重要。在实际应用中，组织还应根据其具体需求和风险情况采取适当的安全措施，并与专业的网络安全人员合作，以确保网络的安全性和可靠性。

## SQL注入攻击

SQL注入是一种常见的网络攻击，攻击者通过在应用程序的输入字段中插入恶意的SQL代码，以获取未经授权的数据库访问或执行恶意操作。以下是SQL注入攻击的解决方案：

1. 输入验证和过滤：
   - 使用参数化查询或预编译语句：使用参数化查询或预编译语句可以将输入数据与SQL查询分离，从而防止注入攻击。
   - 验证和过滤输入：应用程序应该对用户输入进行验证和过滤，确保只接受预期的数据类型和格式，并剔除潜在的恶意字符，如单引号和分号等。
2. 最小权限原则：
   - 授予数据库账户最小权限：为应用程序连接到数据库的账户授予最小权限，只提供执行必要操作所需的权限，避免使用具有管理员级别权限的账户连接。
3. 错误处理和日志记录：
   - 限制详细的错误信息：在应用程序中限制详细的错误信息输出，避免将敏感信息暴露给攻击者。
   - 完善的日志记录：记录应用程序的操作和异常情况，方便跟踪和审计可能的注入攻击。
4. 使用安全的框架和ORM工具：
   - 使用受信任的框架和ORM（对象关系映射）工具：这些工具通常具有内置的防护机制，可以自动处理输入验证和参数化查询，减少SQL注入的风险。
5. 定期更新和补丁：
   - 更新数据库系统和应用程序：及时应用数据库系统和应用程序的安全补丁和更新，以修复已知的漏洞。
6. 安全意识培训：
   - 教育开发人员和管理员：提供安全意识培训，使开发人员和管理员了解SQL注入攻击的风险，并学习如何编写安全的数据库查询和存储过程。

以上措施并不是绝对的，需要根据具体情况和应用程序的要求进行调整。此外，定期进行安全审计和漏洞扫描也是重要的措施，以确保应用程序的安全性，并保护数据库免受SQL注入等攻击。
