# **MySQL有哪些锁**

![image-20230731151512195](D:\typora\Golang_Engineer\typora-user-images\image-20230731151512195.png)

## **全局锁**

要使用全局锁，则执行这条命令：

```mysql
flush tables with read lock // 执行后，整个数据库就处于只读状态了
```

```mysql
unlock tables // 释放全局锁
```

全局锁使用场景：主要应用于做全库逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

## **表级锁**

在 MySQL 中，表级锁（Table Locks）主要分为两类：读锁（Read Locks）和写锁（Write Locks）。以下是这两类表级锁的详细介绍：

1. **读锁（Read Locks）**：读锁也称为共享锁（Shared Locks），它允许多个事务同时对一个表进行读取操作。当一个事务持有读锁时，其他事务可以对该表进行读操作，但不能进行写操作（如插入、更新、删除等）。读锁的主要目的是确保在事务读取表时，表中的数据不会被其他事务修改。

   示例：`LOCK TABLES table_name READ;`

2. **写锁（Write Locks）**：写锁也称为排他锁（Exclusive Locks），它只允许一个事务在同一时间对一个表进行写操作。当一个事务持有写锁时，其他事务不能对该表进行读或写操作。写锁的主要目的是防止多个事务同时修改表中的数据，从而导致数据不一致。

   示例：`LOCK TABLES table_name WRITE;`

表级锁主要应用于不支持行级锁（如 MyISAM 存储引擎）的场景，或者在某些需要锁定整个表的操作中（如 ALTER TABLE）。虽然表级锁可以简化并发控制，但它会限制事务的并发性，因为对整个表加锁会阻止其他事务同时访问该表。在实际应用中，表级锁通常与其他锁类型（如行级锁、间隙锁等）结合使用，以实现更高效的并发控制。

## **行级锁**

在 MySQL 中，行级锁（Row-Level Locks）主要分为以下几类：

1. **记录锁（Record Locks）**：记录锁是针对单个数据行的锁。当事务需要对某一行数据进行操作（如读取、修改、删除）时，它会在该行上添加记录锁。记录锁确保在事务操作单个数据行时，不会与其他事务发生冲突。记录锁通常在支持行级锁的存储引擎（如 InnoDB）中使用。

2. **间隙锁（Gap Locks）**：间隙锁是针对数据行之间的空隙进行加锁的一种锁类型。它主要用于防止幻读（Phantom Reads）问题，即防止在一个事务处理过程中，其他事务在相同范围内插入新的数据行。间隙锁通常与记录锁一起使用，以实现更细粒度的并发控制。

3. **临键锁（Next-Key Locks）**：临键锁是记录锁和间隙锁的组合，它锁定一个数据行以及该行之前的间隙。临键锁主要用于在可重复读（Repeatable Read）隔离级别下防止幻读问题。临键锁既可以防止其他事务在锁定范围内插入新的数据行，也可以防止其他事务读取或修改已锁定的数据行。

这些行级锁类型在支持行级锁的存储引擎（如 InnoDB）中使用，以实现更高效的并发控制和数据一致性。与表级锁相比，行级锁允许多个事务同时操作不同的数据行，从而提高了事务的并发性。然而，行级锁也会增加锁管理的复杂性，可能导致锁争用和死锁问题。在实际应用中，了解这些行级锁类型及其用途有助于更好地理解和优化 MySQL 的性能。

## 意向锁

MySQL 中的意向锁（Intention Lock）是 InnoDB 存储引擎中的一种特殊锁，它主要用于表明一个事务希望在更细粒度（如行锁）上对数据进行加锁。意向锁并不会阻止其他事务对数据的访问，而是充当一种信号机制，帮助事务在请求行锁之前了解表级别的锁状态。这样可以避免在请求行锁时产生不必要的死锁检测和等待。

意向锁有两种类型：

1. 意向共享锁（Intention Shared Lock，IS）：表示一个事务希望在某个数据行上请求一个共享锁（S）。意向共享锁允许多个事务在同一表上同时持有 IS 锁，但它们不能与意向排他锁（IX）或表级别的排他锁（X）共存。

2. 意向排他锁（Intention Exclusive Lock，IX）：表示一个事务希望在某个数据行上请求一个排他锁（X）。意向排他锁可以与共享锁（S）共存（同一个表的其他行），但不能与意向共享锁（IS）、排他锁（X）或表级别的共享锁（S）（同一行）共存。

在 InnoDB 存储引擎中，当一个事务需要在数据行上请求一个行锁时，它会首先检查表级别的意向锁状态。如果锁状态与请求的行锁兼容，事务会继续请求行锁；否则，事务会等待，直到表级别的意向锁状态变为兼容为止。这种机制确保了事务在请求行锁时可以避免不必要的死锁检测和等待，从而提高了数据库的并发性能。

总之，MySQL 中的意向锁是 InnoDB 存储引擎中一种特殊的锁类型，它主要用于表明一个事务希望在更细粒度（如行锁）上对数据进行加锁。意向锁有助于提高数据库的并发性能，避免不必要的死锁检测和等待。

# **为什么需要加锁**

在 MySQL 数据库中，加锁是为了解决多个并发事务对数据的访问和修改冲突问题，从而保证数据的一致性、完整性和事务的隔离性。以下是为什么 MySQL 需要加锁的主要原因：

1. **保证数据一致性**：加锁可以确保在一个事务执行过程中，其他事务无法同时修改被锁定的数据。这有助于避免数据不一致的问题，例如，一个事务在读取数据时，其他事务对该数据进行了修改。

2. **保证数据完整性**：加锁可以确保事务在执行过程中数据的完整性。例如，在转账操作中，一个事务需要将一定金额从账户 A 转到账户 B，这涉及到两个账户的金额更新。通过加锁，可以确保在这个过程中，其他事务无法访问或修改这两个账户的数据，从而保证数据完整性。

3. **实现事务隔离性**：加锁有助于实现事务的隔离性，即确保一个事务在执行过程中，其操作对其他事务是不可见的。事务隔离性是数据库事务的四个基本特性（ACID）之一，它有助于防止脏读、不可重复读和幻读等问题。

4. **优化数据库性能**：合理的加锁策略可以提高数据库的并发性能。例如，行级锁允许多个事务同时操作不同的数据行，从而提高了事务的并发性。同时，加锁也可以防止长时间运行的事务阻塞其他事务的执行。

为了实现这些目标，MySQL 提供了多种锁类型，如表级锁、行级锁、间隙锁等，以满足不同场景的需求。了解这些锁类型及其用途有助于更好地理解和优化 MySQL 的性能。

# **MySQL锁粒度**

MySQL 锁粒度是指锁定资源范围的大小。在 MySQL 中，主要有两种锁粒度：表级锁（Table-Level Locks）和行级锁（Row-Level Locks）。以下是这两种锁粒度的详细介绍：

1. **表级锁（Table-Level Locks）**：表级锁是锁定整个表的一种锁类型。当一个事务对一个表进行操作时，它会锁定整个表，使其他事务在此期间无法对该表进行写操作（如插入、更新、删除等）。表级锁的优点是实现简单，加锁开销较小。然而，由于它锁定整个表，会限制事务的并发性，可能导致其他事务等待，从而降低系统的性能。表级锁主要应用于不支持行级锁（如 MyISAM 存储引擎）的场景，或者在某些需要锁定整个表的操作中（如 ALTER TABLE）。

2. **行级锁（Row-Level Locks）**：行级锁是锁定单个数据行的一种锁类型。当一个事务对某一行数据进行操作时，它会在该行上添加锁，使其他事务在此期间无法对该行进行写操作。行级锁的优点是可以提高事务的并发性，允许多个事务同时操作不同的数据行。然而，行级锁也会增加锁管理的复杂性和开销，可能导致锁争用和死锁问题。行级锁通常在支持行级锁的存储引擎（如 InnoDB）中使用。

在实际应用中，应根据性能要求、并发需求以及存储引擎的特性选择适当的锁粒度。通常情况下，行级锁能够提供更高的并发性能，因此在需要支持高并发的场景下，推荐使用支持行级锁的存储引擎（如 InnoDB）。然而，在某些特定场景下，表级锁可能更合适，例如批量数据处理或对整个表进行操作的情况。

# **乐观锁和悲观锁是什么?如何实现?**

乐观锁和悲观锁是两种不同的并发控制策略，它们分别基于对并发冲突的乐观和悲观的预期。

1. **乐观锁（Optimistic Locking）**：乐观锁的策略是假设并发冲突在实际操作中很少发生，因此在事务执行过程中不会对数据加锁。只有在提交事务时，才会检查是否存在其他事务对数据进行了修改。如果存在冲突（如其他事务已经修改了数据），则事务会回滚并重新执行或者报错。乐观锁适用于并发冲突较少的场景，可以减少锁的开销，提高性能。

   **实现方法**：乐观锁通常通过为数据添加版本号（Version）或时间戳（Timestamp）来实现。在更新数据时，会检查版本号或时间戳是否发生变化，如果没有变化，则说明没有其他事务修改过数据，可以提交事务；如果发生变化，则说明存在冲突，需要回滚事务并重新执行或报错。以下是使用版本号实现乐观锁的一个示例（假设数据表中有 version 字段）：

   ```sql
   -- 查询数据时获取 version
   SELECT id, name, version FROM users WHERE id = 1;

   -- 更新数据时检查 version 是否发生变化，如果没有变化则更新数据并增加 version
   UPDATE users SET name = 'new_name', version = version + 1 WHERE id = 1 AND version = [original_version];
   ```

2. **悲观锁（Pessimistic Locking）**：悲观锁的策略是假设并发冲突在实际操作中很容易发生，因此在事务执行过程中会对数据加锁，防止其他事务对数据进行修改。这样可以确保事务在执行过程中数据的一致性和完整性，但也可能导致其他事务等待，降低性能。悲观锁适用于并发冲突较多的场景，需要保证数据的严格一致性。

   **实现方法**：悲观锁通常通过数据库提供的锁机制来实现，如行级锁、表级锁等。在查询数据时，可以使用 `SELECT ... FOR UPDATE` 语句来加锁，使其他事务在此期间无法对数据进行写操作。以下是使用悲观锁的一个示例：

   ```sql
   -- 查询数据并加锁，防止其他事务修改数据
   SELECT * FROM users WHERE id = 1 FOR UPDATE;
   
   -- 更新数据
   UPDATE users SET name = 'new_name' WHERE id = 1;
   
   -- 提交事务，释放锁
   COMMIT;
   ```

在实际应用中，应根据具体场景和性能要求选择合适的并发控制策略。乐观锁和悲观锁各有优缺点，需要权衡锁开销、性能和数据一致性等因素进行选择。

# **InnoDB的行锁是如何实现的?**

InnoDB 存储引擎实现行锁（Row-Level Locks）主要通过一种叫作**记录锁（Record Locks）**的机制。记录锁是基于索引的一种行级锁定方式，它锁定索引记录，从而达到锁定数据行的目的。除了记录锁，InnoDB 还支持**间隙锁（Gap Locks）**和**临键锁（Next-Key Locks）**来解决幻读（Phantom Read）等问题。

以下是 InnoDB 各种行锁实现方式的详细介绍：

1. **记录锁（Record Locks）**：记录锁是一种粒度最小的行级锁，它直接锁定索引记录。当事务需要对某一行数据进行操作时，InnoDB 会在该行对应的索引记录上加锁。记录锁只能锁定具体的索引记录，如果没有索引，InnoDB 会使用隐藏的聚簇索引（Clustered Index）进行锁定。

2. **间隙锁（Gap Locks）**：间隙锁是锁定索引记录之间的“间隙”。这种锁的目的是防止其他事务在锁定间隙范围内插入新的记录，从而导致幻读等问题。间隙锁并不锁定具体的索引记录，而是锁定一个范围。

3. **临键锁（Next-Key Locks）**：临键锁是记录锁和间隙锁的组合。当事务对某一行数据进行操作时，InnoDB 会在该行对应的索引记录上加记录锁，并在该记录之前的间隙上加间隙锁。这样可以确保事务操作的数据行以及相关的间隙都被锁定，防止其他事务在锁定范围内进行插入、更新或删除操作。

InnoDB 的行锁实现方式使其在高并发场景下具有较好的性能。事务可以在不影响其他数据行的情况下并发地操作各自的数据行。然而，行锁也可能导致锁争用和死锁等问题，需要在实际应用中进行监控和优化。为了提高锁定性能，建议尽量使用较小的事务和高效的索引策略。

# **什么是两阶段锁协议?**

两阶段锁协议（Two-Phase Locking Protocol，简称 2PL）是一种用于控制并发事务的锁定协议，以确保事务的一致性和隔离性。两阶段锁协议可以防止脏读（Dirty Read）、不可重复读（Non-repeatable Read）和幻读（Phantom Read）等问题，从而实现事务的隔离级别。两阶段锁协议的基本思想是将事务的执行过程分为两个阶段：加锁阶段（Locking Phase）和解锁阶段（Unlocking Phase）。

以下是两阶段锁协议的详细介绍：

1. **加锁阶段（Locking Phase）**：在加锁阶段，事务会逐渐请求并获得所需的锁。事务可以请求多个锁，但必须在执行读写操作之前获得所有所需的锁。在此阶段，事务只能请求新的锁，不能释放已经获得的锁。

2. **解锁阶段（Unlocking Phase）**：在解锁阶段，事务逐渐释放已经获得的锁。解锁阶段开始于事务的第一个锁被释放时，并持续到事务释放所有锁。在此阶段，事务不能再请求新的锁。

两阶段锁协议可以确保事务的串行化执行，从而满足事务的隔离性要求。然而，两阶段锁协议可能导致锁争用和死锁等问题，需要在实际应用中进行监控和优化。为了提高性能和减少锁开销，可以使用乐观锁（Optimistic Locking）等替代方案。

需要注意的是，两阶段锁协议并不是一种锁的实现方式，而是一种规范事务锁定行为的协议。实际的锁实现方式，如行锁（Row-Level Locks）、表锁（Table-Level Locks）等，可以根据具体需求在遵循两阶段锁协议的基础上进行选择和优化。

**优点：**

1. **死锁预防：** 2PL协议可以有效地预防死锁，因为在事务获取锁的过程中，会在一定的顺序内获取锁，并且在释放锁之后不再获取新的锁，从而降低了死锁的可能性。
2. **简单易实现：** 2PL是一种相对简单的并发控制协议，易于实现。其基本规则清晰，易于理解和操作。
3. **保证事务的一致性：** 2PL协议通过强制事务在获取锁后才能对数据进行修改，从而确保了事务执行的一致性。

**缺点：**

1. **性能瓶颈：** 2PL在事务获取锁后，其他事务必须等待锁的释放，这可能导致性能瓶颈，特别是在高并发环境下。
2. **资源利用率低：** 由于2PL在事务执行过程中可能持有锁，导致其他事务无法访问相同的资源，从而降低了资源利用率。
3. **长事务影响：** 长时间持有锁的事务可能导致其他事务等待时间过长，降低了系统的并发性能。
4. **不适用于某些场景：** 2PL可能不适用于某些对并发性能要求较高的场景，例如在线事务处理系统（OLTP），因为它可能导致锁争用，从而影响系统的响应时间。

# **什么是三级封锁协议？**

- 一级封锁协议：事务在修改数据之前必须先对其加X锁，直到事务结束才释放。可以解决丢失修改问题（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）；
- 二级封锁协议：在一级的基础上，事务在读取数据之前必须先加S锁，读完后释放。可以解决脏读问题（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法进行读取，避免了读取脏数据）；
- 三级封锁协议：在二级的基础上，事务在读取数据之前必须先加S锁，直到事务结束才能释放。可以解决不可重复读问题（避免了在事务结束前其它事务对数据加X锁进行修改，保证了事务期间数据不会被其它事务更新）

# **MySQL死锁了，怎么办？**

MySQL 中的死锁是指两个或多个事务互相等待对方释放锁资源，导致所有事务都无法继续执行的情况。死锁可能导致性能下降和事务阻塞等问题。当发生死锁时，可以采取以下方法来处理和避免：

1. **识别死锁**：首先需要识别死锁的存在。可以通过查看 MySQL 的错误日志和 `SHOW ENGINE INNODB STATUS` 命令来检查是否存在死锁。另外，可以通过在 `my.cnf` 配置文件中设置 `innodb_print_all_deadlocks = 1` 来记录所有死锁信息。

2. **死锁超时设置**：可以通过设置 `innodb_deadlock_detect_timeout` 参数来控制 MySQL 检测死锁的超时时间。当死锁检测超时后，MySQL 会自动选择一个事务进行回滚，以解除死锁。需要注意的是，这种方法可能导致事务回滚和重试的开销。

3. **事务顺序执行**：尽量保证事务按照相同的顺序访问资源。例如，在多个事务中，尽量让它们按照相同的顺序访问表和行。这样可以减少死锁的发生概率。

4. **减小锁粒度**：尽量使用较小的锁粒度，如行锁（Row-Level Locks），以提高并发性能。同时，尽量避免长时间持有锁，以减少死锁的可能性。

5. **优化事务设计**：尽量减少事务的大小和执行时间，以降低死锁的发生概率。在事务中，避免使用不必要的锁。同时，尽量避免在事务中执行可能导致锁延迟的操作，如用户输入或其他 I/O 操作。

6. **重试事务**：在应用程序中，如果事务因死锁而回滚，可以考虑自动重试事务。在重试事务前，可以引入随机等待时间（如随机延迟 1-5 秒），以减少重试时死锁的可能性。

7. **使用乐观锁**：在适当的场景下，可以使用乐观锁（Optimistic Locking）替代悲观锁（Pessimistic Locking）。乐观锁在检查数据一致性的同时进行更新操作，从而降低锁的开销和死锁的可能性。

8. **监控和诊断**：持续监控 MySQL 的性能和死锁情况，使用诊断工具（如 MySQL Enterprise Monitor、Percona Toolkit 等）分析并优化事务和锁定策略。

# **加了什么锁，导致死锁的？**

MySQL 中的死锁通常是由于多个事务之间的锁竞争导致的。这些锁可能包括以下类型：

1. **共享锁（Shared Lock，S锁）**：当一个事务需要读取一行数据时，它会请求一个共享锁。共享锁允许多个事务同时读取同一行数据，但在共享锁存在时，其他事务不能对该行数据进行修改。死锁可能发生在多个事务试图获取同一行数据的共享锁时，同时又有一个事务请求该行数据的排他锁。

2. **排他锁（Exclusive Lock，X锁）**：当一个事务需要修改或删除一行数据时，它会请求一个排他锁。排他锁不允许其他事务同时读取或修改同一行数据。死锁可能发生在多个事务试图获取同一行数据的排他锁时。

3. **意向共享锁（Intention Shared Lock，IS锁）**：当一个事务打算在表的某一行上请求共享锁时，它会先请求一个意向共享锁。意向共享锁表示一个事务想要在表的某一行上获取共享锁。意向共享锁允许其他事务在同一表上请求共享锁，但不允许请求排他锁。

4. **意向排他锁（Intention Exclusive Lock，IX锁）**：当一个事务打算在表的某一行上请求排他锁时，它会先请求一个意向排他锁。意向排他锁表示一个事务想要在表的某一行上获取排他锁。意向排他锁允许其他事务在同一表上请求共享锁或意向共享锁，但不允许请求排他锁或意向排他锁。

5. **自增锁（Auto-Increment Lock）**：当使用自增主键时，插入新纪录的事务会请求一个自增锁。自增锁确保了自增主键的唯一性和连续性。然而，在高并发场景下，自增锁可能导致事务阻塞和死锁等问题。

死锁通常发生在以下情况：

- 两个或多个事务同时请求相同资源上的不同类型的锁，例如事务A请求行1的共享锁，事务B请求行1的排他锁。
- 两个或多个事务在相互等待对方释放锁资源，例如事务A持有行1的排他锁，请求行2的排他锁；事务B持有行2的排他锁，请求行1的排他锁。

要避免死锁，可以按照前面回答中提到的方法进行优化和调整。